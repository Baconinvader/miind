#!/usr/bin/env python
import os
import re
import argparse
import numpy as np
import xml.etree.ElementTree as ET
import directories3 as directories
from collections import Counter
import reporting
import connections
import variables
import algorithms

# These algorithms can feature in a MeshAlgorithmGroup simulation, and no others
MESH_ALGORITHM_GROUP_LIST = ['GridAlgorithmGroup', 'MeshAlgorithmGroup', 'DelayAlgorithm', 'RateFunctor' ]

def parse_rate_functors(algorithms):
     s=''
     for algorithm in algorithms:
          if algorithm.attrib['type'] == 'RateFunctor':
             expression = algorithm.find('expression')
             name=re.sub(r'\s+', '_', algorithm.attrib['name']) # a user may use white space, we need to replace it
             s += 'static MPILib::Rate ' + name + '( MPILib::Time t ){\n'
             s += '\treturn ' + expression.text + ';\n'
             s += '}\n\n'
     return s


def generate_variable_declarations(variables):
     s = ''
     for variable in variables:
          s += 'const float ' + variable.attrib['Name'] + ' = ' + variable.text + ';\n'
     s += '\n'
     return s


def generate_preamble(fn, variables, nodes, algorithms, connections, parameters, cuda):
    '''Generates the function declarations, required for RateFunctors etc in the C++ file. fn is the file name where the C++
    is to be written. variable, nodes and algorithms are XML elements.'''

    if cuda == True:
         template_argument = 'fptype'
    else:
         template_argument = 'MPILib::Rate'

    with open(fn,'w') as f:
        f.write('//Machine-generated by miind.py. Edit at your own risk.\n\n')
        f.write('#include <boost/timer/timer.hpp>\n')
        f.write('#include <GeomLib.hpp>\n')
        f.write('#include <TwoDLib.hpp>\n')
        if cuda == True: f.write('#include <CudaTwoDLib.hpp>\n')
        f.write('#include <MPILib/include/RateAlgorithmCode.hpp>\n')
        f.write('#include <MPILib/include/SimulationRunParameter.hpp>\n')
        f.write('#include <MPILib/include/DelayAlgorithmCode.hpp>\n')
        f.write('#include <MPILib/include/RateFunctorCode.hpp>\n')
        f.write('#include <MPILib/include/MiindTvbModelAbstract.hpp>\n')
        f.write('#include <MiindLib/VectorizedNetwork.hpp>\n\n')
        if cuda == True: f.write('typedef CudaTwoDLib::fptype fptype;\n')
        f.write('\n')

def constructor_override(outfile,tree,typ):
    variable_list = tree.findall('Variable')
    variables.parse_variables(variable_list,outfile)
    t_step = tree.find('SimulationRunParameter/t_step')

    outfile.write('\tMiindModel(int num_nodes, long simulation_length ):\n')
    outfile.write('\t\tMiindTvbModelAbstract(num_nodes, simulation_length), vec_network('+ t_step.text +'),_count(0){\n')
    outfile.write('#ifdef ENABLE_MPI\n')
    outfile.write('\t// initialise the mpi environment this cannot be forwarded to a class\n')
    outfile.write('\tboost::mpi::environment env();\n')
    outfile.write('#endif\n')
    outfile.write('}\n\n')

    outfile.write('\tMiindModel(long simulation_length ):\n')
    outfile.write('\t\tMiindTvbModelAbstract(1, simulation_length), vec_network('+ t_step.text +'),_count(0){\n')
    outfile.write('#ifdef ENABLE_MPI\n')
    outfile.write('\t// initialise the mpi environment this cannot be forwarded to a class\n')
    outfile.write('\tboost::mpi::environment env();\n')
    outfile.write('#endif\n')
    outfile.write('}\n\n')

    # for some reason we need an explicit copy constructor
    outfile.write('\tMiindModel(const MiindModel& rhs):\n')
    outfile.write('\tMiindTvbModelAbstract(1, rhs._simulation_length), vec_network('+ t_step.text +'),_count(rhs._count) {}\n\n')

    if len(variable_list) > 0:
        outfile.write('\tMiindModel(int num_nodes, long simulation_length \n')
        variables.parse_variables_as_parameters(variable_list,outfile)
        outfile.write('):\n')
        outfile.write('\t\tMiindTvbModelAbstract(num_nodes, simulation_length), vec_network('+ t_step.text +'),_count(0)\n')
        variables.parse_variables_as_constructor_defaults(variable_list, outfile)
        outfile.write('{\n')
        outfile.write('#ifdef ENABLE_MPI\n')
        outfile.write('\t// initialise the mpi environment this cannot be forwarded to a class\n')
        outfile.write('\tboost::mpi::environment env();\n')
        outfile.write('#endif\n')
        outfile.write('}\n\n')

    if len(variable_list) > 0:
        outfile.write('\tMiindModel(long simulation_length \n')
        variables.parse_variables_as_parameters(variable_list,outfile)
        outfile.write('):\n')
        outfile.write('\t\tMiindTvbModelAbstract(1, simulation_length), vec_network('+ t_step.text +'),_count(0)\n')
        variables.parse_variables_as_constructor_defaults(variable_list, outfile)
        outfile.write('{\n')
        outfile.write('#ifdef ENABLE_MPI\n')
        outfile.write('\t// initialise the mpi environment this cannot be forwarded to a class\n')
        outfile.write('\tboost::mpi::environment env();\n')
        outfile.write('#endif\n')
        outfile.write('}\n\n')

def abstract_type(type):
    if type ==  "DelayedConnection":
        s = "MPILib::" + type
    else:
        s = "double"
    return 'MPILib::MiindTvbModelAbstract<' + s + ', MPILib::utilities::CircularDistribution>'

def define_abstract_type(type):
    if type ==  "DelayedConnection":
        s = "MPILib::" + type
    else:
        s = "double"
    return 'define_python_MiindTvbModelAbstract<' + s + ', MPILib::utilities::CircularDistribution>();\n'


def function_overrides(outfile,tree,typ):
    outfile.write('\n\tvoid endSimulation(){\n')
    outfile.write('\t\t'+ abstract_type(typ) +'::endSimulation();\n')
    outfile.write('\t}\n')

    outfile.write('\tint startSimulation(){\n')
    outfile.write('\t\tvec_network.setupLoop(true);\n')
    outfile.write('\t\tpb = new utilities::ProgressBar((int)_simulation_length/_time_step);\n')
    outfile.write('\t\treturn 0;\n')
    outfile.write('\t}\n')

    outfile.write('\t\tboost::python::list evolveSingleStep(boost::python::list c){\n')
    outfile.write('\t\tboost::python::ssize_t len = boost::python::len(c);\n')
    outfile.write('\t\tstd::vector<double> activity = std::vector<double>();\n\n')

    outfile.write('\t\tfor(int i=0; i<len; i++) {\n')
    outfile.write('\t\t\tdouble ca = boost::python::extract<double>(c[i]);\n')
    outfile.write('\t\t\tactivity.push_back(ca);\n')
    outfile.write('\t\t}\n\n')

    outfile.write('\t\tboost::python::list out;\n')
    outfile.write('\t\tfor(auto& it : vec_network.singleStep(activity,_count)) {\n')
    outfile.write('\t\t\tout.append(it);\n')
    outfile.write('\t\t}\n\n')

    outfile.write('\t\t_count++;\n')
    outfile.write('\t\t(*pb)++;\n\n')

    outfile.write('\t\treturn out;\n')
    outfile.write('\t}\n\n')

def generate_opening(fn, tree, typ, algorithms, variables):
    with open(fn,'a') as outfile:
        outfile.write('class MiindModel : public ' + abstract_type(typ) + ' {\n')
        outfile.write('public:\n\n')
        outfile.write('\tMiindLib::VectorizedNetwork vec_network;\n')
        outfile.write('\tpugi::xml_document doc;\n')
        outfile.write('\tstd::vector<MPILib::NodeId> _display_nodes;\n')
        outfile.write('\tstd::vector<MPILib::NodeId> _rate_nodes;\n')
        outfile.write('\tstd::vector<MPILib::NodeId> _density_nodes;\n')
        outfile.write('\tstd::vector<MPILib::Time> _density_node_start_times;\n')
        outfile.write('\tstd::vector<MPILib::Time> _density_node_end_times;\n')
        outfile.write('\tstd::vector<MPILib::Time> _density_node_intervals;\n')
        outfile.write('\tunsigned int _count;\n')
        outfile.write('\n')

        # the rate functor functions need to be declared before the main program
        function_declarations = parse_rate_functors(algorithms)
        variable_declarations = generate_variable_declarations(variables)
        outfile.write(function_declarations)
        outfile.write(variable_declarations)
        constructor_override(outfile, tree,typ)
        function_overrides(outfile,tree,typ)
        outfile.write('\n')
        outfile.write('\tvoid init(boost::python::list params)\n')
        outfile.write('\t{\n')
        t_step = tree.find('SimulationRunParameter/t_step')
        outfile.write('\t\t_time_step = ' + t_step.text + ';\n')
        outfile.write('\t\tfor(int i=0; i<_num_nodes; i++) {\n')

def generate_closing(fn,parameters,tree,type,prog_name,members):
    start_time = parameters.find('t_begin').text
    end_time = parameters.find('t_end').text
    time_step = parameters.find('t_step').text

    steps = ''
    master_steps = parameters.findall('master_steps')
    if(len(master_steps) > 0):
        steps = master_steps[0].text

    node_list = tree.findall('Nodes/Node')
    nodemap = node_name_to_node_id(node_list)

    '''Generates the closing statements in the C++ file.'''
    with open(fn,'a') as f:
        f.write(reporting.define_display_nodes(tree,nodemap))
        f.write(reporting.define_rate_nodes(tree,nodemap))
        f.write(reporting.define_density_nodes(tree,nodemap))
        f.write('\n')
        f.write('\t\t_rate_nodes = rate_nodes;\n')
        f.write('\t\t_display_nodes = display_nodes;\n')
        f.write('\t\t_density_nodes = density_nodes;\n')
        f.write('\t\t_density_node_start_times = density_node_start_times;\n')
        f.write('\t\t_density_node_end_times = density_node_end_times;\n')
        f.write('\t\t_density_node_intervals = density_node_intervals;\n')
        f.write('\t\t\n')
        f.write('\tvec_network.setDisplayNodes(_display_nodes);\n')
        f.write('\tvec_network.setRateNodes(_rate_nodes);\n')
        f.write('\tvec_network.setDensityNodes(_density_nodes,_density_node_start_times,_density_node_end_times,_density_node_intervals);\n')
        f.write('\n')
        f.write('\tvec_network.initOde2DSystem('+ steps +');\n')
        f.write('}\n')
        f.write('}\n')
        f.write('\n')
        for t in algorithms.RATEFUNCTIONS:
            f.write(t)
        f.write('\n\n')
        f.write(members)
        f.write('};\n\n')
        variable_list = tree.findall('Variable')
        f.write('BOOST_PYTHON_MODULE(lib' + prog_name + ')\n')
        f.write('{\n')
        f.write('\tusing namespace boost::python;\n')
        f.write('\t' + define_abstract_type(type))
        f.write('\tclass_<MiindModel, bases<' + abstract_type(type) + '>>("MiindModel", init<int,long>())\n')

        if len(variable_list) > 0:
            var_types = variables.parse_variable_types(variable_list)
            outfile.write('\t.def(init<int,long' + var_types + '>())\n')
        f.write('\t.def("init", &MiindModel::init)\n')
        f.write('\t.def("init", &MiindModel::init)\n')
        f.write('\t.def("startSimulation", &MiindModel::startSimulation)\n')
        f.write('\t.def("endSimulation", &MiindModel::endSimulation)\n')
        f.write('\t.def("evolveSingleStep", &MiindModel::evolveSingleStep);\n')
        f.write('}\n')

def process_tree(root):

    variables=root.findall(".//Variable")
    nodes=root.findall('.//Node')
    algorithms=root.findall('.//Algorithm')
    connections=root.findall('.//Connection')
    external_incoming_connections = root.findall('.//IncomingConnection')
    external_outgoing_connections = root.findall('.//OutgoingConnection')
    parameters=root.findall('.//SimulationRunParameter')
    io=root.findall('.//SimulationIO')
    return variables, nodes, algorithms, connections, external_incoming_connections, external_outgoing_connections, parameters[0], io

def parse(fn):
    '''Takes a filename. Puts the file with filename fn through the XML parser. Returns nothing.'''
    try:
        tree = ET.parse(fn)
        root = tree.getroot()

    except FileNotFoundError:
        print('No file ' + fn)
    return root

def generate_model_files(fn, nodes,algorithms):
    members = ''
    with open(fn,'a') as f:
        node_id = 0
        for node in nodes:
            algname = node.attrib['algorithm']
            for alg in algorithms:
                if alg.attrib['name'] == algname: # here we assume the name is unique
                    algorithm = alg

            if algorithm.attrib['type'] == 'MeshAlgorithmGroup':
              ref = 0.0
              if 'tau_refractive' in algorithm.attrib.keys():
                   ref = algorithm.attrib['tau_refractive']

              f.write('\tpugi::xml_parse_result result' + str(node_id) + ' = doc.load_file(\"' + algorithm.attrib['modelfile'] +'\");\n')
              f.write('\tpugi::xml_node  root' + str(node_id) + ' = doc.first_child();\n\n')
              members += '\tstd::vector<TwoDLib::Mesh> mesh' + str(node_id) +';\n'
              f.write('\tmesh' + str(node_id) +'.push_back(TwoDLib::RetrieveMeshFromXML(root' + str(node_id) + '));\n')
              members += '\tstd::vector<std::vector<TwoDLib::Redistribution>> vec_rev' + str(node_id) + ';\n'
              f.write('\tvec_rev' + str(node_id) + '.push_back(TwoDLib::RetrieveMappingFromXML("Reversal",root' + str(node_id) + '));\n')
              members += '\tstd::vector<std::vector<TwoDLib::Redistribution>> vec_res' + str(node_id) + ';\n'
              f.write('\tvec_res' + str(node_id) + '.push_back(TwoDLib::RetrieveMappingFromXML("Reset",root' + str(node_id) + '));\n\n')
              f.write('\tvec_network.addMeshNode(mesh'+ str(node_id) +'[i], vec_rev'+ str(node_id) +'[i], vec_res'+ str(node_id) +'[i], ' + ref + ');\n')
              f.write('\n')

              node_id = node_id + 1

            elif algorithm.attrib['type'] == 'GridAlgorithmGroup':
              ref = 0.0
              if 'tau_refractive' in algorithm.attrib.keys():
                 ref = algorithm.attrib['tau_refractive']

              f.write('\tpugi::xml_parse_result result' + str(node_id) + ' = doc.load_file(\"' + algorithm.attrib['modelfile'] +'\");\n')
              f.write('\tpugi::xml_node  root' + str(node_id) + ' = doc.first_child();\n\n')
              members += '\tstd::vector<TwoDLib::Mesh> mesh' + str(node_id) +';\n'
              f.write('\tmesh' + str(node_id) +'.push_back(TwoDLib::RetrieveMeshFromXML(root' + str(node_id) + '));\n')
              members += '\tstd::vector<std::vector<TwoDLib::Redistribution>> vec_rev' + str(node_id) + ';\n'
              f.write('\tvec_rev' + str(node_id) + '.push_back(TwoDLib::RetrieveMappingFromXML("Reversal",root' + str(node_id) + '));\n')
              members += '\tstd::vector<std::vector<TwoDLib::Redistribution>> vec_res' + str(node_id) + ';\n'
              f.write('\tvec_res' + str(node_id) + '.push_back(TwoDLib::RetrieveMappingFromXML("Reset",root' + str(node_id) + '));\n\n')
              members += '\tstd::vector<TwoDLib::TransitionMatrix> transform' + str(node_id) + ';\n'
              f.write('\ttransform' + str(node_id) + '.push_back(TwoDLib::TransitionMatrix(\"' + algorithm.attrib['transformfile'] + '\"));\n')
              f.write('\tvec_network.addGridNode(mesh'+ str(node_id) +'[i], transform'+ str(node_id) +'[i], ' + str(algorithm.attrib['start_v']) + ', ' + str(algorithm.attrib['start_w']) +', vec_rev'+ str(node_id) +'[i], vec_res'+ str(node_id) +'[i], '+ ref +');\n')
              f.write('\n')

              node_id = node_id + 1

            elif algorithm.attrib['type'] == 'RateFunctor':
                rn = 'MiindModel::' + algorithm.attrib['name']
                f.write('\tvec_network.addRateNode(' + rn + ');\n')
                node_id = node_id + 1

    return members

def extract_efficacy(fn):
     '''Extract efficacy from a matrix file. Takes a filename, returns efficacy as a single float. In the
     file efficacies are represented by two numbers. We will assume for now that one of them in zero. We will
     return the non-zero number as efficacy.'''

     with open(fn) as f:
          line=f.readline()
          nrs = [ float(x) for x in line.split()]
          if nrs[0] == 0.:
               return nrs[1]
          else:
               if nrs[1] != 0:
                    raise ValueError('Expected at least one non-zero value')
               return nrs[0]

def construct_CSR_map_external(nodes,algorithms,connections):
    '''Creates a list that corresponds one-to-one with the connection structure. Returns a tuple: [0] node name of receiving node,[1] matrix file name for this connection  '''
    csrlist=[]
    combi = []
    for connection in connections:
         for node in nodes:
              if connection.attrib['Node'] == node.attrib['name']:
                   # we have the right node, now see if it's a MeshAlgorithmGroup
                   nodealgorithm=node.attrib['algorithm']
                   for algorithm in algorithms:
                        if nodealgorithm == algorithm.attrib['name']:
                             if algorithm.attrib['type'] == 'MeshAlgorithmGroup':

                                  mfs=algorithm.findall('MatrixFile')
                                  mfn= [ mf.text for mf in mfs]
                                  efficacy=float(connection.text.split()[1])
                                  effs= [extract_efficacy(fn) for fn in mfn]

                                  candidates=[]
                                  for i, eff in enumerate(effs):
                                       if np.isclose(eff,efficacy):
                                            candidates.append(i)
                                  if len(candidates) == 0: raise ValueError('No efficacy found that corresponds to the connection efficacy ' + str(efficacy))
                                  if len(candidates) > 1: raise ValueError('Same efficacy found twice')

                                  count = Counter(combi)
                                  combi.append((connection.attrib['Node']))
                                  nr_connection = count[(connection.attrib['Node'])]
                                  csrlist.append([node.attrib['name'],mfn[candidates[0]], effs[candidates[0]],nr_connection,connection])
    return csrlist

def construct_CSR_map(nodes,algorithms,connections):
     '''Creates a list that corresponds one-to-one with the connection structure. Returns a tuple: [0] node name of receiving node,[1] matrix file name for this connection  '''
     csrlist=[]
     combi = []
     for connection in connections:
          for node in nodes:
               if connection.attrib['Out'] == node.attrib['name']:
                    # we have the right node, now see if it's a MeshAlgorithmGroup
                    nodealgorithm=node.attrib['algorithm']
                    for algorithm in algorithms:
                         if nodealgorithm == algorithm.attrib['name']:
                              if algorithm.attrib['type'] == 'MeshAlgorithmGroup':

                                   mfs=algorithm.findall('MatrixFile')
                                   mfn= [ mf.text for mf in mfs]
                                   efficacy=float(connection.text.split()[1])
                                   effs= [extract_efficacy(fn) for fn in mfn]

                                   candidates=[]
                                   for i, eff in enumerate(effs):
                                        if np.isclose(eff,efficacy):
                                             candidates.append(i)
                                   if len(candidates) == 0: raise ValueError('No efficacy found that corresponds to the connection efficacy ' + str(efficacy))
                                   if len(candidates) > 1: raise ValueError('Same efficacy found twice')

                                   count = Counter(combi)
                                   combi.append((connection.attrib['Out'],connection.attrib['In']))
                                   nr_connection = count[(connection.attrib['Out'],connection.attrib['In'])]
                                   csrlist.append([node.attrib['name'],mfn[candidates[0]], effs[candidates[0]],connection.attrib['In'],nr_connection,connection])

     return csrlist

def construct_grid_connection_map_external(nodes,algorithms,connections):
    '''Creates a list that corresponds one-to-one with the connection structure. Returns a tuple: [0] node name of receiving node,[1] matrix file name for this connection  '''
    gridlist=[]

    for connection in connections:
         for node in nodes:
              if connection.attrib['Node'] == node.attrib['name']:
                   # we have the right node, now see if it's a MeshAlgorithmGroup
                   nodealgorithm=node.attrib['algorithm']
                   for algorithm in algorithms:
                        if nodealgorithm == algorithm.attrib['name']:
                             if algorithm.attrib['type'] == 'GridAlgorithmGroup':
                                  gridlist.append([node.attrib['name'],connection])

    return gridlist

def construct_grid_connection_map(nodes,algorithms,connections):
     '''Creates a list that corresponds one-to-one with the connection structure. Returns a tuple: [0] node name of receiving node,[1] matrix file name for this connection  '''
     gridlist=[]

     for connection in connections:
          for node in nodes:
               if connection.attrib['Out'] == node.attrib['name']:
                    # we have the right node, now see if it's a MeshAlgorithmGroup
                    nodealgorithm=node.attrib['algorithm']
                    for algorithm in algorithms:
                         if nodealgorithm == algorithm.attrib['name']:
                              if algorithm.attrib['type'] == 'GridAlgorithmGroup':
                                   gridlist.append([node.attrib['name'],connection])

     return gridlist

def node_name_to_node_id(nodes):
     '''Create a map from name to NodeId from node elements. Return this map.'''
     d ={}
     for i,node in enumerate(nodes):
          d[node.attrib['name']] = i
     return d

def construct_monitor_external(nodes,algorithms, connections):
    '''Creates a list that corresponds one-to-one with the connection structure. Returns a tuple: [0] node name of receiving node,[1] matrix file name for this connection  '''
    gridlist=[]

    for connection in connections:
         for node in nodes:
              if connection.attrib['Node'] == node.attrib['name']:
                   # we have the right node, now see if it's a MeshAlgorithmGroup
                   nodealgorithm=node.attrib['algorithm']
                   for algorithm in algorithms:
                        if nodealgorithm == algorithm.attrib['name']:
                             if algorithm.attrib['type'] == 'GridAlgorithmGroup':
                                  gridlist.append([node.attrib['name'],connection])

    return gridlist

def generate_connections(fn,conns, external_incoming_connections, external_outgoing_connections, nodes, algorithms):
    members = ''
    grid_cons = construct_grid_connection_map(nodes, algorithms, conns)
    grid_cons_ext = construct_grid_connection_map_external(nodes, algorithms, external_incoming_connections)
    mesh_cons = construct_CSR_map(nodes, algorithms, conns)
    mesh_cons_ext = construct_CSR_map_external(nodes, algorithms, external_incoming_connections)
    mesh_ext = construct_monitor_external(nodes, algorithms, external_outgoing_connections)
    nodemap = node_name_to_node_id(nodes)

    external_node_id = 0
    with open(fn,'a') as f:
        for cn in mesh_cons:
            cpp_name = 'mat_' + str(nodemap[cn[0]]) + '_' + str(nodemap[cn[3]]) + '_' + str(cn[4])
            members += 'std::vector<TwoDLib::TransitionMatrix> ' + cpp_name + ';\n'
            f.write('\t' + cpp_name + '.push_back(TwoDLib::TransitionMatrix(\"' + cn[1] + '\"));\n')
            f.write(connections.parse_mesh_connection(cn[5], nodemap, cpp_name +'[i]', 'vec_network'))

        for cn in mesh_cons_ext:
            cpp_name = 'mat_' + str(nodemap[cn[0]]) + '_ext_' + str(cn[3])
            members += 'std::vector<TwoDLib::TransitionMatrix> ' + cpp_name + ';\n'
            f.write('\t' + cpp_name + '.push_back(TwoDLib::TransitionMatrix(\"' + cn[1] + '\"));\n')
            f.write(connections.parse_external_incoming_mesh_connection(cn[4], nodemap, cpp_name +'[i]', external_node_id, 'vec_network'))
            external_node_id = external_node_id + 1

        for cn in grid_cons:
            f.write(connections.parse_grid_connection(cn[1],nodemap, 'vec_network'))

        for cn in grid_cons_ext:
            f.write(connections.parse_external_incoming_grid_connection(cn[1],nodemap, external_node_id, 'vec_network'))
            external_node_id = external_node_id + 1

        for cn in mesh_ext:
            f.write(connections.parse_external_outgoing_connection(cn[1],nodemap, 'vec_network'))

        f.write('\n')

    return members


def create_cpp_file(xmlfile, dirpath, progname, modname, cuda):
    '''Write the C++ file specified by xmlfile into dirpath as progname.'''
    root=parse(xmlfile)
    variables, nodes, algorithms, connections, external_incoming_connections, external_outgoing_connections, parameter, io=process_tree(root)
    if sanity_check(algorithms) == False: raise NameError('An algorithm incompatible with MeshAlgorithmGroup was used')
    if cuda == True:
         fn=os.path.join(dirpath, progname)+'.cu'
    else:
         fn=os.path.join(dirpath, progname)+'.cpp'

    generate_preamble(fn, variables, nodes, algorithms,connections,parameter, cuda)
    weighttype = root.find('WeightType')
    generate_opening(fn, root, weighttype.text, algorithms, variables)
    members = generate_model_files(fn,nodes,algorithms)
    members += generate_connections(fn,connections,external_incoming_connections, external_outgoing_connections,nodes,algorithms)
    generate_closing(fn,parameter,root,weighttype.text,progname,members)

def sanity_check(algorithms):
    '''Check if only the allowd algorithms feature in this simulation. Returns True if so, False otherwise.'''

    for algorithm in algorithms:
        if algorithm.attrib['type'] not in MESH_ALGORITHM_GROUP_LIST:
            return False
        else:
            return True

def mesh_algorithm_group(root):
    '''True if there are MeshAlgorithmGroup algorithms in the XML file, false otherwise.'''
    algorithms=root.findall('.//Algorithm')

    for algorithm in algorithms:
        if algorithm.attrib['type'] in ["MeshAlgorithmGroup","GridAlgorithmGroup"]:
            return True

    return False

def produce_mesh_algorithm_version(dirname, filename, modname, root, enable_mpi, enable_openmp, enable_root, cuda):
    '''Entry point for the vector version of a MIIND C++ file. Filename is file name of the XML file, dirname is the user-specified directory hierarchy
    where the C++ file will be generated and the simulation will be stored. The simulation file will be placed in directory <dirname>/<xml_file_name>.'''

    if not directories.PATH_VARS_DEFINED:
        directories.initialize_global_variables()

    for xmlfile in filename:
        progname = directories.check_and_strip_name(xmlfile)
        dirpath = directories.create_dir(os.path.join(dirname, progname))
        SOURCE_FILE = progname + '.cpp'
        if cuda:
            SOURCE_FILE = progname + '.cu'
        directories.insert_cmake_template_lib(progname,dirpath,enable_mpi, enable_openmp, enable_root,cuda,SOURCE_FILE)
        create_cpp_file(xmlfile, dirpath, progname, modname, cuda)
        directories.move_model_files(xmlfile,dirpath)

def generate_vectorized_network_lib(dirname, filename, modname, enable_mpi, enable_openmp, enable_root, enable_cuda):
    fn = filename[0]
    root=parse(fn)
    if mesh_algorithm_group(root) == True:
        # Run the MeshAlgorithm version
        produce_mesh_algorithm_version(dirname, filename, modname, root, enable_mpi, enable_openmp, enable_root, enable_cuda)
    else:
        # Simply run the old script
        directories.add_shared_library(dirname, filename, modname, enable_mpi, enable_openmp, enable_root, False)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Generate C++ from XML descriptions.')
    parser.add_argument('--d', help = 'Provide a packaging directory.',nargs = '?')
    parser.add_argument('-c', '--cuda', action="store_true", dest="cuda", help="if specified, cuda will be generated")
    parser.add_argument('-m','--m', help = 'A list of model and matrix files that will be copied to every executable directory.''', nargs='+')
    parser.add_argument('xml file', metavar='XML File', nargs = '*', help = 'Will create an entry in the build tree for each XML file, provided the XML file is valid.')
    parser.add_argument('--mpi', help = 'Enable MPI.', action='store_true')
    parser.add_argument('--openmp', help = 'Enable OPENMP.', action='store_true')
    parser.add_argument('--no_root', help = 'Disable ROOT.', action='store_true')

    args = parser.parse_args()


    filename = vars(args)['xml file']
    dirname  = vars(args)['d']
    modname  = vars(args)['m']
    enable_mpi = vars(args)['mpi']
    enable_openmp = vars(args)['openmp']
    disable_root = vars(args)['no_root']
    enable_cuda = vars(args)['cuda']

    fn = filename[0]
    root=parse(fn)
    if mesh_algorithm_group(root) == True:
        # Run the MeshAlgorithm version
        produce_mesh_algorithm_version(dirname, filename, modname, root, vars(args)['cuda'])
    else:
        # Simply run the old script
        if dirname == None:
            raise ValueError("This option is deprecated")
            fn = filename[0]
            directories.add_shared_library(fn,modname, enable_mpi, enable_openmp, disable_root)
        else:
            directories.add_shared_library(dirname, filename, modname, enable_mpi, enable_openmp, disable_root, enable_cuda)
