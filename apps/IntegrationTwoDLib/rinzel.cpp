//Machine-generated by miind.py. Edit at your own risk.

#include <boost/timer/timer.hpp>
#include <GeomLib.hpp>
#include <TwoDLib.hpp>
#include <MPILib/include/MPINetworkCode.hpp>
#include <MPILib/include/RateAlgorithmCode.hpp>
#include <MPILib/include/SimulationRunParameter.hpp>
#include <MPILib/include/report/handler/RootReportHandler.hpp>
#include <MPILib/include/WilsonCowanAlgorithm.hpp>
#include <MPILib/include/PersistantAlgorithm.hpp>
#include <MPILib/include/DelayAlgorithmCode.hpp>
#include <MPILib/include/RateFunctorCode.hpp>
#include "Euler.hpp"

typedef MPILib::MPINetwork<MPILib::DelayedConnection, MPILib::utilities::CircularDistribution> Network;
	// defining variables
const double TIME_END = 10000.0;


vector<TwoDLib::Redistribution> RetrieveMappingFromXML(const std::string& type, pugi::xml_node root)
{
	Pred pred(type);
	pugi::xml_node rev_node = root.find_child(pred);

	if (rev_node.name() != std::string("Mapping") ||
	    rev_node.attribute("type").value() != type)
	  throw TwoDLib::TwoDLibException("Couldn't find mapping in model file");

	std::ostringstream ostrev;
	rev_node.print(ostrev);
	std::istringstream istrev(ostrev.str());
	vector<TwoDLib::Redistribution> vec_rev = TwoDLib::ReMapping(istrev);
	return vec_rev;
}

TwoDLib::Mesh RetrieveMeshFromXML(pugi::xml_node root)
{
        pugi::xml_node mesh_node = root.first_child();
	if (mesh_node.name() != std::string("Mesh") )
	  throw TwoDLib::TwoDLibException("Couldn't find mesh node in model file");
	std::ostringstream ostmesh;
	mesh_node.print(ostmesh);
	std::istringstream istmesh(ostmesh.str());
	TwoDLib::Mesh mesh(istmesh);
	return mesh;
}

MPILib::Rate RateFunction_1(MPILib::Time t){
	return 3.5;
}
MPILib::Rate RateFunction_2(MPILib::Time t){
	return t > 1500 ? 3.5 : 0;
}


int main(int argc, char *argv[]){
	Network network;
	boost::timer::auto_cpu_timer t;

#ifdef ENABLE_MPI
	// initialise the mpi environment this cannot be forwarded to a class
	boost::mpi::environment env(argc, argv);
#endif

	try {	// generating algorithms

	pugi::xml_document doc;	
	pugi::xml_parse_result result = doc.load_file("rinzel.model");
	pugi::xml_node  root = doc.first_child();
 
	TwoDLib::Mesh mesh1 = RetrieveMeshFromXML(root);
	TwoDLib::Mesh mesh2 = mesh1;

	std::vector<TwoDLib::Redistribution> vec_rev1 = RetrieveMappingFromXML("Reversal",root);
	std::vector<TwoDLib::Redistribution> vec_rev2 = vec_rev1;
	std::vector<TwoDLib::Redistribution> vec_res1 = RetrieveMappingFromXML("Reset",root);
	std::vector<TwoDLib::Redistribution> vec_res2 = vec_res1;

	std::vector<TwoDLib::Mesh> vec_vec_mesh { mesh1, mesh2 };
	std::vector< std::vector<TwoDLib::Redistribution> > vec_vec_rev { vec_rev1, vec_rev2 };
	std::vector< std::vector<TwoDLib::Redistribution> > vec_vec_res { vec_res1, vec_res2 };
 
	TwoDLib::Ode2DSystemGroup group(vec_vec_mesh,vec_vec_rev, vec_vec_res);
	group.Initialize(0,0,0);
	group.Initialize(1,0,0);

	TwoDLib::TransitionMatrix mat1("rinzel_0.1_0_0_0_.mat");
        TwoDLib::TransitionMatrix mat2("rinzel_-0.1_0_0_0_.mat");

	TwoDLib::CSRMatrix csr01(mat2,group,0); // inhibitory so mat2
	TwoDLib::CSRMatrix csr02(mat1,group,0); // excitatory so mat1; mesh id 0 relates to the first mesh
	TwoDLib::CSRMatrix csr10(mat2,group,1); // inhibitory so mat2; mesh id 1 relates to the second mesh
	TwoDLib::CSRMatrix csr13(mat1,group,1); // excitatory so mat 1

	std::vector<TwoDLib::CSRMatrix> vecmat{csr01, csr02, csr10, csr13}; // the input rates corresponding to these matrices must be presented in the same order

	// Establish number of steps
	MPILib::Time t_step = mesh1.TimeStep();
	MPILib::Number n_steps = static_cast<MPILib::Number>(floor(TIME_END/t_step));
	std::cout << "Number of simulation steps: " << n_steps << std::endl;;
	
	// Placeholder for firing rates
	const MPILib::Number nr_populations = 4;
	std::vector<MPILib::Rate> vec_rates(nr_populations,0.0);
	std::vector<MPILib::Rate> vec_input(nr_populations,0.0);

	// create a vector for the derivative                                                                                                                                       
	std::vector<double> dydt(group.Mass().size());

	// Euler step parameter
	TwoDLib::MasterParameter par(500);
	double h = 1./par._N_steps*mesh1.TimeStep();

	// generating connections
	DelayedConnection con_0_2_0(1.,0.1,0);
	DelayedConnection con_1_3_0(1.,0.1,0);
	DelayedConnection con_1_0_0(500.,-0.1,0);
	DelayedConnection con_0_1_0(500.,-0.1,0);

	for(MPILib::Index istep = 0; istep < n_steps; istep++){
	  MPILib::Time t = t_step*istep;
	  group.Evolve();
	  // retain Hugh's original numbering convention

	  vec_input[0] = con_0_1_0._number_of_connections*vec_rates[1]; 
	  vec_input[1] = con_0_2_0._number_of_connections*vec_rates[2];
	  vec_input[2] = con_1_0_0._number_of_connections*vec_rates[0]; 
	  vec_input[3] = con_1_3_0._number_of_connections*vec_rates[3];

	  for (MPILib::Index i_part = 0; i_part < par._N_steps; i_part++ ){
	    TwoDLib::ClearDerivative(dydt);
	    TwoDLib::CalculateDerivative(group,dydt,vecmat,vec_input);
	    TwoDLib::AddDerivative(group.Mass(),dydt,h);
	  }

	  group.RedistributeProbability();
	  group.RemapReversal();

	  vec_rates[0] = group.F()[0];
	  vec_rates[1] = group.F()[1];
	  vec_rates[2] = RateFunction_1(t);
	  vec_rates[3] = RateFunction_2(t);

	  if (istep%1 == 0) std::cout << mesh1.TimeStep()*istep << " " << group.F()[0] << " " << group.F()[1] << std::endl;
	}

	std::ofstream ofst1("dens1.dat");
	std::ofstream ofst2("dens2.dat");

	std::vector<std::ostream*> vec_stream{ &ofst1, &ofst2};
	group.Dump(vec_stream);

	} catch(std::exception& exc){
		std::cout << exc.what() << std::endl;
#ifdef ENABLE_MPI
	//Abort the MPI environment in the correct way :
	env.abort(1);
	#endif 
	}

	std::cout << "Overall time spend\n";
	t.report();
		
	return 0;
}
