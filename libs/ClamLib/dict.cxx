//
// File generated by rootcint at Mon Jul 25 20:48:14 2011

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME dict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "dict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::WeightedLink< double > WeightedLinklEdoublegR;
      #else
      class WeightedLinklEdoublegR  :  public ::TNamed {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WeightedLinklEdoublegR() throw() {};
         ::ClamLib::Id _id_from; //
         ::ClamLib::Id _id_to; //
         double _weight; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void ClamLibcLcLRootLayerDescription_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLRootLayerDescription(void *p = 0);
   static void *newArray_ClamLibcLcLRootLayerDescription(Long_t size, void *p);
   static void delete_ClamLibcLcLRootLayerDescription(void *p);
   static void deleteArray_ClamLibcLcLRootLayerDescription(void *p);
   static void destruct_ClamLibcLcLRootLayerDescription(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::RootLayerDescription*)
   {
      ::ClamLib::RootLayerDescription *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::RootLayerDescription >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::RootLayerDescription", ::ClamLib::RootLayerDescription::Class_Version(), "./RootLayerDescription.h", 28,
                  typeid(::ClamLib::RootLayerDescription), DefineBehavior(ptr, ptr),
                  &::ClamLib::RootLayerDescription::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::RootLayerDescription) );
      instance.SetNew(&new_ClamLibcLcLRootLayerDescription);
      instance.SetNewArray(&newArray_ClamLibcLcLRootLayerDescription);
      instance.SetDelete(&delete_ClamLibcLcLRootLayerDescription);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLRootLayerDescription);
      instance.SetDestructor(&destruct_ClamLibcLcLRootLayerDescription);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::RootLayerDescription*)
   {
      return GenerateInitInstanceLocal((::ClamLib::RootLayerDescription*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::RootLayerDescription*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLRootLayeredNetDescription_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLRootLayeredNetDescription(void *p = 0);
   static void *newArray_ClamLibcLcLRootLayeredNetDescription(Long_t size, void *p);
   static void delete_ClamLibcLcLRootLayeredNetDescription(void *p);
   static void deleteArray_ClamLibcLcLRootLayeredNetDescription(void *p);
   static void destruct_ClamLibcLcLRootLayeredNetDescription(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::RootLayeredNetDescription*)
   {
      ::ClamLib::RootLayeredNetDescription *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::RootLayeredNetDescription >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::RootLayeredNetDescription", ::ClamLib::RootLayeredNetDescription::Class_Version(), "./RootLayeredNetDescription.h", 35,
                  typeid(::ClamLib::RootLayeredNetDescription), DefineBehavior(ptr, ptr),
                  &::ClamLib::RootLayeredNetDescription::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::RootLayeredNetDescription) );
      instance.SetNew(&new_ClamLibcLcLRootLayeredNetDescription);
      instance.SetNewArray(&newArray_ClamLibcLcLRootLayeredNetDescription);
      instance.SetDelete(&delete_ClamLibcLcLRootLayeredNetDescription);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLRootLayeredNetDescription);
      instance.SetDestructor(&destruct_ClamLibcLcLRootLayeredNetDescription);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::RootLayeredNetDescription*)
   {
      return GenerateInitInstanceLocal((::ClamLib::RootLayeredNetDescription*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::RootLayeredNetDescription*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLId_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLId(void *p = 0);
   static void *newArray_ClamLibcLcLId(Long_t size, void *p);
   static void delete_ClamLibcLcLId(void *p);
   static void deleteArray_ClamLibcLcLId(void *p);
   static void destruct_ClamLibcLcLId(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::Id*)
   {
      ::ClamLib::Id *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::Id >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::Id", ::ClamLib::Id::Class_Version(), "./Id.h", 44,
                  typeid(::ClamLib::Id), DefineBehavior(ptr, ptr),
                  &::ClamLib::Id::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::Id) );
      instance.SetNew(&new_ClamLibcLcLId);
      instance.SetNewArray(&newArray_ClamLibcLcLId);
      instance.SetDelete(&delete_ClamLibcLcLId);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLId);
      instance.SetDestructor(&destruct_ClamLibcLcLId);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::Id*)
   {
      return GenerateInitInstanceLocal((::ClamLib::Id*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::Id*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLIndexWeight_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLIndexWeight(void *p = 0);
   static void *newArray_ClamLibcLcLIndexWeight(Long_t size, void *p);
   static void delete_ClamLibcLcLIndexWeight(void *p);
   static void deleteArray_ClamLibcLcLIndexWeight(void *p);
   static void destruct_ClamLibcLcLIndexWeight(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::IndexWeight*)
   {
      ::ClamLib::IndexWeight *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::IndexWeight >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::IndexWeight", ::ClamLib::IndexWeight::Class_Version(), "./IndexWeight.h", 28,
                  typeid(::ClamLib::IndexWeight), DefineBehavior(ptr, ptr),
                  &::ClamLib::IndexWeight::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::IndexWeight) );
      instance.SetNew(&new_ClamLibcLcLIndexWeight);
      instance.SetNewArray(&newArray_ClamLibcLcLIndexWeight);
      instance.SetDelete(&delete_ClamLibcLcLIndexWeight);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLIndexWeight);
      instance.SetDestructor(&destruct_ClamLibcLcLIndexWeight);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::IndexWeight*)
   {
      return GenerateInitInstanceLocal((::ClamLib::IndexWeight*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::IndexWeight*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLCircuitDescription_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLCircuitDescription(void *p = 0);
   static void *newArray_ClamLibcLcLCircuitDescription(Long_t size, void *p);
   static void delete_ClamLibcLcLCircuitDescription(void *p);
   static void deleteArray_ClamLibcLcLCircuitDescription(void *p);
   static void destruct_ClamLibcLcLCircuitDescription(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::CircuitDescription*)
   {
      ::ClamLib::CircuitDescription *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::CircuitDescription >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::CircuitDescription", ::ClamLib::CircuitDescription::Class_Version(), "./CircuitDescription.h", 29,
                  typeid(::ClamLib::CircuitDescription), DefineBehavior(ptr, ptr),
                  &::ClamLib::CircuitDescription::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::CircuitDescription) );
      instance.SetNew(&new_ClamLibcLcLCircuitDescription);
      instance.SetNewArray(&newArray_ClamLibcLcLCircuitDescription);
      instance.SetDelete(&delete_ClamLibcLcLCircuitDescription);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLCircuitDescription);
      instance.SetDestructor(&destruct_ClamLibcLcLCircuitDescription);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::CircuitDescription*)
   {
      return GenerateInitInstanceLocal((::ClamLib::CircuitDescription*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::CircuitDescription*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLCircuitNodeRole_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLCircuitNodeRole(void *p = 0);
   static void *newArray_ClamLibcLcLCircuitNodeRole(Long_t size, void *p);
   static void delete_ClamLibcLcLCircuitNodeRole(void *p);
   static void deleteArray_ClamLibcLcLCircuitNodeRole(void *p);
   static void destruct_ClamLibcLcLCircuitNodeRole(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::CircuitNodeRole*)
   {
      ::ClamLib::CircuitNodeRole *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::CircuitNodeRole >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::CircuitNodeRole", ::ClamLib::CircuitNodeRole::Class_Version(), "./CircuitNodeRole.h", 47,
                  typeid(::ClamLib::CircuitNodeRole), DefineBehavior(ptr, ptr),
                  &::ClamLib::CircuitNodeRole::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::CircuitNodeRole) );
      instance.SetNew(&new_ClamLibcLcLCircuitNodeRole);
      instance.SetNewArray(&newArray_ClamLibcLcLCircuitNodeRole);
      instance.SetDelete(&delete_ClamLibcLcLCircuitNodeRole);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLCircuitNodeRole);
      instance.SetDestructor(&destruct_ClamLibcLcLCircuitNodeRole);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::CircuitNodeRole*)
   {
      return GenerateInitInstanceLocal((::ClamLib::CircuitNodeRole*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::CircuitNodeRole*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLInputOutputPair_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLInputOutputPair(void *p = 0);
   static void *newArray_ClamLibcLcLInputOutputPair(Long_t size, void *p);
   static void delete_ClamLibcLcLInputOutputPair(void *p);
   static void deleteArray_ClamLibcLcLInputOutputPair(void *p);
   static void destruct_ClamLibcLcLInputOutputPair(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::InputOutputPair*)
   {
      ::ClamLib::InputOutputPair *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::InputOutputPair >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::InputOutputPair", ::ClamLib::InputOutputPair::Class_Version(), "./InputOutputPair.h", 27,
                  typeid(::ClamLib::InputOutputPair), DefineBehavior(ptr, ptr),
                  &::ClamLib::InputOutputPair::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::InputOutputPair) );
      instance.SetNew(&new_ClamLibcLcLInputOutputPair);
      instance.SetNewArray(&newArray_ClamLibcLcLInputOutputPair);
      instance.SetDelete(&delete_ClamLibcLcLInputOutputPair);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLInputOutputPair);
      instance.SetDestructor(&destruct_ClamLibcLcLInputOutputPair);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::InputOutputPair*)
   {
      return GenerateInitInstanceLocal((::ClamLib::InputOutputPair*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::InputOutputPair*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLCircuitInfo_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLCircuitInfo(void *p = 0);
   static void *newArray_ClamLibcLcLCircuitInfo(Long_t size, void *p);
   static void delete_ClamLibcLcLCircuitInfo(void *p);
   static void deleteArray_ClamLibcLcLCircuitInfo(void *p);
   static void destruct_ClamLibcLcLCircuitInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::CircuitInfo*)
   {
      ::ClamLib::CircuitInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::CircuitInfo >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::CircuitInfo", ::ClamLib::CircuitInfo::Class_Version(), "./CircuitInfo.h", 31,
                  typeid(::ClamLib::CircuitInfo), DefineBehavior(ptr, ptr),
                  &::ClamLib::CircuitInfo::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::CircuitInfo) );
      instance.SetNew(&new_ClamLibcLcLCircuitInfo);
      instance.SetNewArray(&newArray_ClamLibcLcLCircuitInfo);
      instance.SetDelete(&delete_ClamLibcLcLCircuitInfo);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLCircuitInfo);
      instance.SetDestructor(&destruct_ClamLibcLcLCircuitInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::CircuitInfo*)
   {
      return GenerateInitInstanceLocal((::ClamLib::CircuitInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::CircuitInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLSimulationInfoBlock_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLSimulationInfoBlock(void *p = 0);
   static void *newArray_ClamLibcLcLSimulationInfoBlock(Long_t size, void *p);
   static void delete_ClamLibcLcLSimulationInfoBlock(void *p);
   static void deleteArray_ClamLibcLcLSimulationInfoBlock(void *p);
   static void destruct_ClamLibcLcLSimulationInfoBlock(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::SimulationInfoBlock*)
   {
      ::ClamLib::SimulationInfoBlock *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::SimulationInfoBlock >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::SimulationInfoBlock", ::ClamLib::SimulationInfoBlock::Class_Version(), "./SimulationInfoBlock.h", 46,
                  typeid(::ClamLib::SimulationInfoBlock), DefineBehavior(ptr, ptr),
                  &::ClamLib::SimulationInfoBlock::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::SimulationInfoBlock) );
      instance.SetNew(&new_ClamLibcLcLSimulationInfoBlock);
      instance.SetNewArray(&newArray_ClamLibcLcLSimulationInfoBlock);
      instance.SetDelete(&delete_ClamLibcLcLSimulationInfoBlock);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLSimulationInfoBlock);
      instance.SetDestructor(&destruct_ClamLibcLcLSimulationInfoBlock);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::SimulationInfoBlock*)
   {
      return GenerateInitInstanceLocal((::ClamLib::SimulationInfoBlock*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlock*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void ClamLibcLcLSimulationInfoBlockVector_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void *new_ClamLibcLcLSimulationInfoBlockVector(void *p = 0);
   static void *newArray_ClamLibcLcLSimulationInfoBlockVector(Long_t size, void *p);
   static void delete_ClamLibcLcLSimulationInfoBlockVector(void *p);
   static void deleteArray_ClamLibcLcLSimulationInfoBlockVector(void *p);
   static void destruct_ClamLibcLcLSimulationInfoBlockVector(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ClamLib::SimulationInfoBlockVector*)
   {
      ::ClamLib::SimulationInfoBlockVector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ClamLib::SimulationInfoBlockVector >(0);
      static ::ROOT::TGenericClassInfo 
         instance("ClamLib::SimulationInfoBlockVector", ::ClamLib::SimulationInfoBlockVector::Class_Version(), "./SimulationInfoBlockVector.h", 28,
                  typeid(::ClamLib::SimulationInfoBlockVector), DefineBehavior(ptr, ptr),
                  &::ClamLib::SimulationInfoBlockVector::Dictionary, isa_proxy, 4,
                  sizeof(::ClamLib::SimulationInfoBlockVector) );
      instance.SetNew(&new_ClamLibcLcLSimulationInfoBlockVector);
      instance.SetNewArray(&newArray_ClamLibcLcLSimulationInfoBlockVector);
      instance.SetDelete(&delete_ClamLibcLcLSimulationInfoBlockVector);
      instance.SetDeleteArray(&deleteArray_ClamLibcLcLSimulationInfoBlockVector);
      instance.SetDestructor(&destruct_ClamLibcLcLSimulationInfoBlockVector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ClamLib::SimulationInfoBlockVector*)
   {
      return GenerateInitInstanceLocal((::ClamLib::SimulationInfoBlockVector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlockVector*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void WeightedLinklEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void WeightedLinklEdoublegR_Dictionary();
   static void *new_WeightedLinklEdoublegR(void *p = 0);
   static void *newArray_WeightedLinklEdoublegR(Long_t size, void *p);
   static void delete_WeightedLinklEdoublegR(void *p);
   static void deleteArray_WeightedLinklEdoublegR(void *p);
   static void destruct_WeightedLinklEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::WeightedLink<double>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::WeightedLink<double>) == sizeof(::ROOT::Shadow::WeightedLinklEdoublegR));
      ::WeightedLink<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::WeightedLink<double> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("WeightedLink<double>", ::WeightedLink<double>::Class_Version(), "./WeightedLink.h", 35,
                  typeid(::WeightedLink<double>), DefineBehavior(ptr, ptr),
                  &WeightedLinklEdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(::WeightedLink<double>) );
      instance.SetNew(&new_WeightedLinklEdoublegR);
      instance.SetNewArray(&newArray_WeightedLinklEdoublegR);
      instance.SetDelete(&delete_WeightedLinklEdoublegR);
      instance.SetDeleteArray(&deleteArray_WeightedLinklEdoublegR);
      instance.SetDestructor(&destruct_WeightedLinklEdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::WeightedLink<double>*)
   {
      return GenerateInitInstanceLocal((::WeightedLink<double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::WeightedLink<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void WeightedLinklEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::WeightedLink<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

      namespace ClamLib {
//______________________________________________________________________________
TClass *RootLayerDescription::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *RootLayerDescription::Class_Name()
{
   return "ClamLib::RootLayerDescription";
}

//______________________________________________________________________________
const char *RootLayerDescription::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayerDescription*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RootLayerDescription::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayerDescription*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void RootLayerDescription::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayerDescription*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *RootLayerDescription::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayerDescription*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *RootLayeredNetDescription::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *RootLayeredNetDescription::Class_Name()
{
   return "ClamLib::RootLayeredNetDescription";
}

//______________________________________________________________________________
const char *RootLayeredNetDescription::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayeredNetDescription*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RootLayeredNetDescription::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayeredNetDescription*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void RootLayeredNetDescription::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayeredNetDescription*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *RootLayeredNetDescription::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::RootLayeredNetDescription*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *Id::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *Id::Class_Name()
{
   return "ClamLib::Id";
}

//______________________________________________________________________________
const char *Id::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::Id*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Id::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::Id*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Id::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::Id*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Id::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::Id*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *IndexWeight::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *IndexWeight::Class_Name()
{
   return "ClamLib::IndexWeight";
}

//______________________________________________________________________________
const char *IndexWeight::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::IndexWeight*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int IndexWeight::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::IndexWeight*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void IndexWeight::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::IndexWeight*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *IndexWeight::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::IndexWeight*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *CircuitDescription::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *CircuitDescription::Class_Name()
{
   return "ClamLib::CircuitDescription";
}

//______________________________________________________________________________
const char *CircuitDescription::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitDescription*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int CircuitDescription::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitDescription*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void CircuitDescription::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitDescription*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *CircuitDescription::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitDescription*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *CircuitNodeRole::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *CircuitNodeRole::Class_Name()
{
   return "ClamLib::CircuitNodeRole";
}

//______________________________________________________________________________
const char *CircuitNodeRole::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitNodeRole*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int CircuitNodeRole::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitNodeRole*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void CircuitNodeRole::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitNodeRole*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *CircuitNodeRole::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitNodeRole*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *InputOutputPair::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *InputOutputPair::Class_Name()
{
   return "ClamLib::InputOutputPair";
}

//______________________________________________________________________________
const char *InputOutputPair::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::InputOutputPair*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int InputOutputPair::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::InputOutputPair*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void InputOutputPair::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::InputOutputPair*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *InputOutputPair::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::InputOutputPair*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *CircuitInfo::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *CircuitInfo::Class_Name()
{
   return "ClamLib::CircuitInfo";
}

//______________________________________________________________________________
const char *CircuitInfo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitInfo*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int CircuitInfo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitInfo*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void CircuitInfo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitInfo*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *CircuitInfo::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::CircuitInfo*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *SimulationInfoBlock::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *SimulationInfoBlock::Class_Name()
{
   return "ClamLib::SimulationInfoBlock";
}

//______________________________________________________________________________
const char *SimulationInfoBlock::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlock*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int SimulationInfoBlock::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlock*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void SimulationInfoBlock::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlock*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *SimulationInfoBlock::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlock*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
      namespace ClamLib {
//______________________________________________________________________________
TClass *SimulationInfoBlockVector::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *SimulationInfoBlockVector::Class_Name()
{
   return "ClamLib::SimulationInfoBlockVector";
}

//______________________________________________________________________________
const char *SimulationInfoBlockVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlockVector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int SimulationInfoBlockVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlockVector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void SimulationInfoBlockVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlockVector*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *SimulationInfoBlockVector::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ClamLib::SimulationInfoBlockVector*)0x0)->GetClass();
   return fgIsA;
}

} // namespace ClamLib
//______________________________________________________________________________
template <> TClass *WeightedLink<double>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *WeightedLink<double>::Class_Name()
{
   return "WeightedLink<double>";
}

//______________________________________________________________________________
template <> const char *WeightedLink<double>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::WeightedLink<double>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int WeightedLink<double>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::WeightedLink<double>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void WeightedLink<double>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::WeightedLink<double>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *WeightedLink<double>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::WeightedLink<double>*)0x0)->GetClass();
   return fgIsA;
}

      namespace ClamLib {
//______________________________________________________________________________
void Id::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::Id.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::Id::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::Id::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void Id::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::Id.
      typedef ::ClamLib::Id msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_id_value", &_id_value);
      TObject::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLId(void *p) {
      return  p ? new(p) ::ClamLib::Id : new ::ClamLib::Id;
   }
   static void *newArray_ClamLibcLcLId(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::Id[nElements] : new ::ClamLib::Id[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLId(void *p) {
      delete ((::ClamLib::Id*)p);
   }
   static void deleteArray_ClamLibcLcLId(void *p) {
      delete [] ((::ClamLib::Id*)p);
   }
   static void destruct_ClamLibcLcLId(void *p) {
      typedef ::ClamLib::Id current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::Id

      namespace ClamLib {
//______________________________________________________________________________
void CircuitInfo::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::CircuitInfo.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::CircuitInfo::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::CircuitInfo::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void CircuitInfo::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::CircuitInfo.
      typedef ::ClamLib::CircuitInfo msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_id_ann", &_id_ann);
      R__insp.InspectMember(_id_ann, "_id_ann.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_id_external", &_id_external);
      R__insp.InspectMember(_id_external, "_id_external.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_vec_id", (void*)&_vec_id);
      R__insp.InspectMember("vector<Id>", (void*)&_vec_id, "_vec_id.", false);
      TNamed::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLCircuitInfo(void *p) {
      return  p ? new(p) ::ClamLib::CircuitInfo : new ::ClamLib::CircuitInfo;
   }
   static void *newArray_ClamLibcLcLCircuitInfo(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::CircuitInfo[nElements] : new ::ClamLib::CircuitInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLCircuitInfo(void *p) {
      delete ((::ClamLib::CircuitInfo*)p);
   }
   static void deleteArray_ClamLibcLcLCircuitInfo(void *p) {
      delete [] ((::ClamLib::CircuitInfo*)p);
   }
   static void destruct_ClamLibcLcLCircuitInfo(void *p) {
      typedef ::ClamLib::CircuitInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::CircuitInfo

//______________________________________________________________________________
template <> void WeightedLink<double>::Streamer(TBuffer &R__b)
{
   // Stream an object of class WeightedLink<double>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(WeightedLink<double>::Class(),this);
   } else {
      R__b.WriteClassBuffer(WeightedLink<double>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void WeightedLinklEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class WeightedLink<double>.
      typedef ::ROOT::Shadow::WeightedLinklEdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::WeightedLink<double>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_id_from", &sobj->_id_from);
      R__insp.InspectMember(sobj->_id_from, "_id_from.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_id_to", &sobj->_id_to);
      R__insp.InspectMember(sobj->_id_to, "_id_to.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_weight", &sobj->_weight);
      sobj->TNamed::ShowMembers(R__insp);
   }

}

template <> void WeightedLink<double>::ShowMembers(TMemberInspector &R__insp)
{
   ::ROOT::WeightedLinklEdoublegR_ShowMembers(this, R__insp);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_WeightedLinklEdoublegR(void *p) {
      return  p ? new(p) ::WeightedLink<double> : new ::WeightedLink<double>;
   }
   static void *newArray_WeightedLinklEdoublegR(Long_t nElements, void *p) {
      return p ? new(p) ::WeightedLink<double>[nElements] : new ::WeightedLink<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_WeightedLinklEdoublegR(void *p) {
      delete ((::WeightedLink<double>*)p);
   }
   static void deleteArray_WeightedLinklEdoublegR(void *p) {
      delete [] ((::WeightedLink<double>*)p);
   }
   static void destruct_WeightedLinklEdoublegR(void *p) {
      typedef ::WeightedLink<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::WeightedLink<double>

      namespace ClamLib {
//______________________________________________________________________________
void RootLayerDescription::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::RootLayerDescription.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::RootLayerDescription::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::RootLayerDescription::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void RootLayerDescription::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::RootLayerDescription.
      typedef ::ClamLib::RootLayerDescription msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nr_x_pixels", &_nr_x_pixels);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nr_y_pixels", &_nr_y_pixels);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nr_features", &_nr_features);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_size_receptive_field_x", &_size_receptive_field_x);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_size_receptive_field_y", &_size_receptive_field_y);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nr_x_skips", &_nr_x_skips);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nr_y_skips", &_nr_y_skips);
      TNamed::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLRootLayerDescription(void *p) {
      return  p ? new(p) ::ClamLib::RootLayerDescription : new ::ClamLib::RootLayerDescription;
   }
   static void *newArray_ClamLibcLcLRootLayerDescription(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::RootLayerDescription[nElements] : new ::ClamLib::RootLayerDescription[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLRootLayerDescription(void *p) {
      delete ((::ClamLib::RootLayerDescription*)p);
   }
   static void deleteArray_ClamLibcLcLRootLayerDescription(void *p) {
      delete [] ((::ClamLib::RootLayerDescription*)p);
   }
   static void destruct_ClamLibcLcLRootLayerDescription(void *p) {
      typedef ::ClamLib::RootLayerDescription current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::RootLayerDescription

      namespace ClamLib {
//______________________________________________________________________________
void RootLayeredNetDescription::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::RootLayeredNetDescription.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::RootLayeredNetDescription::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::RootLayeredNetDescription::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void RootLayeredNetDescription::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::RootLayeredNetDescription.
      typedef ::ClamLib::RootLayeredNetDescription msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_vec_desc", (void*)&_vec_desc);
      R__insp.InspectMember("vector<ClamLib::RootLayerDescription>", (void*)&_vec_desc, "_vec_desc.", false);
      TNamed::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLRootLayeredNetDescription(void *p) {
      return  p ? new(p) ::ClamLib::RootLayeredNetDescription : new ::ClamLib::RootLayeredNetDescription;
   }
   static void *newArray_ClamLibcLcLRootLayeredNetDescription(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::RootLayeredNetDescription[nElements] : new ::ClamLib::RootLayeredNetDescription[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLRootLayeredNetDescription(void *p) {
      delete ((::ClamLib::RootLayeredNetDescription*)p);
   }
   static void deleteArray_ClamLibcLcLRootLayeredNetDescription(void *p) {
      delete [] ((::ClamLib::RootLayeredNetDescription*)p);
   }
   static void destruct_ClamLibcLcLRootLayeredNetDescription(void *p) {
      typedef ::ClamLib::RootLayeredNetDescription current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::RootLayeredNetDescription

      namespace ClamLib {
//______________________________________________________________________________
void IndexWeight::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::IndexWeight.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::IndexWeight::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::IndexWeight::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void IndexWeight::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::IndexWeight.
      typedef ::ClamLib::IndexWeight msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_name_predecessor", &_name_predecessor);
      R__insp.InspectMember(_name_predecessor, "_name_predecessor.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_weight", &_weight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_index", &_index);
      TObject::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLIndexWeight(void *p) {
      return  p ? new(p) ::ClamLib::IndexWeight : new ::ClamLib::IndexWeight;
   }
   static void *newArray_ClamLibcLcLIndexWeight(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::IndexWeight[nElements] : new ::ClamLib::IndexWeight[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLIndexWeight(void *p) {
      delete ((::ClamLib::IndexWeight*)p);
   }
   static void deleteArray_ClamLibcLcLIndexWeight(void *p) {
      delete [] ((::ClamLib::IndexWeight*)p);
   }
   static void destruct_ClamLibcLcLIndexWeight(void *p) {
      typedef ::ClamLib::IndexWeight current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::IndexWeight

      namespace ClamLib {
//______________________________________________________________________________
void InputOutputPair::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::InputOutputPair.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::InputOutputPair::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::InputOutputPair::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void InputOutputPair::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::InputOutputPair.
      typedef ::ClamLib::InputOutputPair msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_id_in", &_id_in);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_id_out", &_id_out);
      TObject::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLInputOutputPair(void *p) {
      return  p ? new(p) ::ClamLib::InputOutputPair : new ::ClamLib::InputOutputPair;
   }
   static void *newArray_ClamLibcLcLInputOutputPair(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::InputOutputPair[nElements] : new ::ClamLib::InputOutputPair[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLInputOutputPair(void *p) {
      delete ((::ClamLib::InputOutputPair*)p);
   }
   static void deleteArray_ClamLibcLcLInputOutputPair(void *p) {
      delete [] ((::ClamLib::InputOutputPair*)p);
   }
   static void destruct_ClamLibcLcLInputOutputPair(void *p) {
      typedef ::ClamLib::InputOutputPair current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::InputOutputPair

      namespace ClamLib {
//______________________________________________________________________________
void CircuitNodeRole::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::CircuitNodeRole.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::CircuitNodeRole::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::CircuitNodeRole::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void CircuitNodeRole::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::CircuitNodeRole.
      typedef ::ClamLib::CircuitNodeRole msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_type", &_type);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_x", &_x);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_y", &_y);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_z", &_z);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_f", &_f);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_isOutput", &_isOutput);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_isPositive", &_isPositive);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_incoming", (void*)&_incoming);
      R__insp.InspectMember("vector<ClamLib::IndexWeight>", (void*)&_incoming, "_incoming.", false);
      TNamed::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLCircuitNodeRole(void *p) {
      return  p ? new(p) ::ClamLib::CircuitNodeRole : new ::ClamLib::CircuitNodeRole;
   }
   static void *newArray_ClamLibcLcLCircuitNodeRole(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::CircuitNodeRole[nElements] : new ::ClamLib::CircuitNodeRole[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLCircuitNodeRole(void *p) {
      delete ((::ClamLib::CircuitNodeRole*)p);
   }
   static void deleteArray_ClamLibcLcLCircuitNodeRole(void *p) {
      delete [] ((::ClamLib::CircuitNodeRole*)p);
   }
   static void destruct_ClamLibcLcLCircuitNodeRole(void *p) {
      typedef ::ClamLib::CircuitNodeRole current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::CircuitNodeRole

      namespace ClamLib {
//______________________________________________________________________________
void CircuitDescription::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::CircuitDescription.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::CircuitDescription::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::CircuitDescription::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void CircuitDescription::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::CircuitDescription.
      typedef ::ClamLib::CircuitDescription msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_b_is_setup", &_b_is_setup);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nr_nodes", &_nr_nodes);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_index", &_index);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_vec_role", (void*)&_vec_role);
      R__insp.InspectMember("vector<ClamLib::CircuitNodeRole>", (void*)&_vec_role, "_vec_role.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_vec_io", (void*)&_vec_io);
      R__insp.InspectMember("vector<ClamLib::InputOutputPair>", (void*)&_vec_io, "_vec_io.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_name_external", &_name_external);
      R__insp.InspectMember(_name_external, "_name_external.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_index_external", &_index_external);
      TNamed::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLCircuitDescription(void *p) {
      return  p ? new(p) ::ClamLib::CircuitDescription : new ::ClamLib::CircuitDescription;
   }
   static void *newArray_ClamLibcLcLCircuitDescription(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::CircuitDescription[nElements] : new ::ClamLib::CircuitDescription[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLCircuitDescription(void *p) {
      delete ((::ClamLib::CircuitDescription*)p);
   }
   static void deleteArray_ClamLibcLcLCircuitDescription(void *p) {
      delete [] ((::ClamLib::CircuitDescription*)p);
   }
   static void destruct_ClamLibcLcLCircuitDescription(void *p) {
      typedef ::ClamLib::CircuitDescription current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::CircuitDescription

      namespace ClamLib {
//______________________________________________________________________________
void SimulationInfoBlock::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::SimulationInfoBlock.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::SimulationInfoBlock::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::SimulationInfoBlock::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void SimulationInfoBlock::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::SimulationInfoBlock.
      typedef ::ClamLib::SimulationInfoBlock msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_name", &_name);
      R__insp.InspectMember(_name, "_name.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_net_desc", &_net_desc);
      R__insp.InspectMember(_net_desc, "_net_desc.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_info", (void*)&_info);
      R__insp.InspectMember("vector<ClamLib::CircuitInfo>", (void*)&_info, "_info.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_circ_desc", &_circ_desc);
      R__insp.InspectMember(_circ_desc, "_circ_desc.");
      TNamed::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLSimulationInfoBlock(void *p) {
      return  p ? new(p) ::ClamLib::SimulationInfoBlock : new ::ClamLib::SimulationInfoBlock;
   }
   static void *newArray_ClamLibcLcLSimulationInfoBlock(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::SimulationInfoBlock[nElements] : new ::ClamLib::SimulationInfoBlock[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLSimulationInfoBlock(void *p) {
      delete ((::ClamLib::SimulationInfoBlock*)p);
   }
   static void deleteArray_ClamLibcLcLSimulationInfoBlock(void *p) {
      delete [] ((::ClamLib::SimulationInfoBlock*)p);
   }
   static void destruct_ClamLibcLcLSimulationInfoBlock(void *p) {
      typedef ::ClamLib::SimulationInfoBlock current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::SimulationInfoBlock

      namespace ClamLib {
//______________________________________________________________________________
void SimulationInfoBlockVector::Streamer(TBuffer &R__b)
{
   // Stream an object of class ClamLib::SimulationInfoBlockVector.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ClamLib::SimulationInfoBlockVector::Class(),this);
   } else {
      R__b.WriteClassBuffer(ClamLib::SimulationInfoBlockVector::Class(),this);
   }
}

} // namespace ClamLib
//______________________________________________________________________________
      namespace ClamLib {
void SimulationInfoBlockVector::ShowMembers(TMemberInspector &R__insp)
{
      // Inspect the data members of an object of class ClamLib::SimulationInfoBlockVector.
      typedef ::ClamLib::SimulationInfoBlockVector msvc_bug_workaround;
      TClass *R__cl = msvc_bug_workaround::IsA();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_vec_info", (void*)&_vec_info);
      R__insp.InspectMember("vector<ClamLib::SimulationInfoBlock>", (void*)&_vec_info, "_vec_info.", false);
      TNamed::ShowMembers(R__insp);
}

} // namespace ClamLib
namespace ROOT {
   // Wrappers around operator new
   static void *new_ClamLibcLcLSimulationInfoBlockVector(void *p) {
      return  p ? new(p) ::ClamLib::SimulationInfoBlockVector : new ::ClamLib::SimulationInfoBlockVector;
   }
   static void *newArray_ClamLibcLcLSimulationInfoBlockVector(Long_t nElements, void *p) {
      return p ? new(p) ::ClamLib::SimulationInfoBlockVector[nElements] : new ::ClamLib::SimulationInfoBlockVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_ClamLibcLcLSimulationInfoBlockVector(void *p) {
      delete ((::ClamLib::SimulationInfoBlockVector*)p);
   }
   static void deleteArray_ClamLibcLcLSimulationInfoBlockVector(void *p) {
      delete [] ((::ClamLib::SimulationInfoBlockVector*)p);
   }
   static void destruct_ClamLibcLcLSimulationInfoBlockVector(void *p) {
      typedef ::ClamLib::SimulationInfoBlockVector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ClamLib::SimulationInfoBlockVector

namespace ROOT {
   void vectorlEClamLibcLcLCircuitInfogR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEClamLibcLcLCircuitInfogR_Dictionary();
   static void *new_vectorlEClamLibcLcLCircuitInfogR(void *p = 0);
   static void *newArray_vectorlEClamLibcLcLCircuitInfogR(Long_t size, void *p);
   static void delete_vectorlEClamLibcLcLCircuitInfogR(void *p);
   static void deleteArray_vectorlEClamLibcLcLCircuitInfogR(void *p);
   static void destruct_vectorlEClamLibcLcLCircuitInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ClamLib::CircuitInfo>*)
   {
      vector<ClamLib::CircuitInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ClamLib::CircuitInfo>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ClamLib::CircuitInfo>", -2, "prec_stl/vector", 49,
                  typeid(vector<ClamLib::CircuitInfo>), DefineBehavior(ptr, ptr),
                  0, &vectorlEClamLibcLcLCircuitInfogR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ClamLib::CircuitInfo>) );
      instance.SetNew(&new_vectorlEClamLibcLcLCircuitInfogR);
      instance.SetNewArray(&newArray_vectorlEClamLibcLcLCircuitInfogR);
      instance.SetDelete(&delete_vectorlEClamLibcLcLCircuitInfogR);
      instance.SetDeleteArray(&deleteArray_vectorlEClamLibcLcLCircuitInfogR);
      instance.SetDestructor(&destruct_vectorlEClamLibcLcLCircuitInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ClamLib::CircuitInfo> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ClamLib::CircuitInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEClamLibcLcLCircuitInfogR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ClamLib::CircuitInfo>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEClamLibcLcLCircuitInfogR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::CircuitInfo> : new vector<ClamLib::CircuitInfo>;
   }
   static void *newArray_vectorlEClamLibcLcLCircuitInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::CircuitInfo>[nElements] : new vector<ClamLib::CircuitInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEClamLibcLcLCircuitInfogR(void *p) {
      delete ((vector<ClamLib::CircuitInfo>*)p);
   }
   static void deleteArray_vectorlEClamLibcLcLCircuitInfogR(void *p) {
      delete [] ((vector<ClamLib::CircuitInfo>*)p);
   }
   static void destruct_vectorlEClamLibcLcLCircuitInfogR(void *p) {
      typedef vector<ClamLib::CircuitInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ClamLib::CircuitInfo>

namespace ROOT {
   void vectorlEClamLibcLcLCircuitNodeRolegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEClamLibcLcLCircuitNodeRolegR_Dictionary();
   static void *new_vectorlEClamLibcLcLCircuitNodeRolegR(void *p = 0);
   static void *newArray_vectorlEClamLibcLcLCircuitNodeRolegR(Long_t size, void *p);
   static void delete_vectorlEClamLibcLcLCircuitNodeRolegR(void *p);
   static void deleteArray_vectorlEClamLibcLcLCircuitNodeRolegR(void *p);
   static void destruct_vectorlEClamLibcLcLCircuitNodeRolegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ClamLib::CircuitNodeRole>*)
   {
      vector<ClamLib::CircuitNodeRole> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ClamLib::CircuitNodeRole>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ClamLib::CircuitNodeRole>", -2, "prec_stl/vector", 49,
                  typeid(vector<ClamLib::CircuitNodeRole>), DefineBehavior(ptr, ptr),
                  0, &vectorlEClamLibcLcLCircuitNodeRolegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ClamLib::CircuitNodeRole>) );
      instance.SetNew(&new_vectorlEClamLibcLcLCircuitNodeRolegR);
      instance.SetNewArray(&newArray_vectorlEClamLibcLcLCircuitNodeRolegR);
      instance.SetDelete(&delete_vectorlEClamLibcLcLCircuitNodeRolegR);
      instance.SetDeleteArray(&deleteArray_vectorlEClamLibcLcLCircuitNodeRolegR);
      instance.SetDestructor(&destruct_vectorlEClamLibcLcLCircuitNodeRolegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ClamLib::CircuitNodeRole> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ClamLib::CircuitNodeRole>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEClamLibcLcLCircuitNodeRolegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ClamLib::CircuitNodeRole>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEClamLibcLcLCircuitNodeRolegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::CircuitNodeRole> : new vector<ClamLib::CircuitNodeRole>;
   }
   static void *newArray_vectorlEClamLibcLcLCircuitNodeRolegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::CircuitNodeRole>[nElements] : new vector<ClamLib::CircuitNodeRole>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEClamLibcLcLCircuitNodeRolegR(void *p) {
      delete ((vector<ClamLib::CircuitNodeRole>*)p);
   }
   static void deleteArray_vectorlEClamLibcLcLCircuitNodeRolegR(void *p) {
      delete [] ((vector<ClamLib::CircuitNodeRole>*)p);
   }
   static void destruct_vectorlEClamLibcLcLCircuitNodeRolegR(void *p) {
      typedef vector<ClamLib::CircuitNodeRole> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ClamLib::CircuitNodeRole>

namespace ROOT {
   void vectorlEClamLibcLcLIdgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEClamLibcLcLIdgR_Dictionary();
   static void *new_vectorlEClamLibcLcLIdgR(void *p = 0);
   static void *newArray_vectorlEClamLibcLcLIdgR(Long_t size, void *p);
   static void delete_vectorlEClamLibcLcLIdgR(void *p);
   static void deleteArray_vectorlEClamLibcLcLIdgR(void *p);
   static void destruct_vectorlEClamLibcLcLIdgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ClamLib::Id>*)
   {
      vector<ClamLib::Id> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ClamLib::Id>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ClamLib::Id>", -2, "prec_stl/vector", 49,
                  typeid(vector<ClamLib::Id>), DefineBehavior(ptr, ptr),
                  0, &vectorlEClamLibcLcLIdgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<ClamLib::Id>) );
      instance.SetNew(&new_vectorlEClamLibcLcLIdgR);
      instance.SetNewArray(&newArray_vectorlEClamLibcLcLIdgR);
      instance.SetDelete(&delete_vectorlEClamLibcLcLIdgR);
      instance.SetDeleteArray(&deleteArray_vectorlEClamLibcLcLIdgR);
      instance.SetDestructor(&destruct_vectorlEClamLibcLcLIdgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ClamLib::Id> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ClamLib::Id>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEClamLibcLcLIdgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ClamLib::Id>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEClamLibcLcLIdgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::Id> : new vector<ClamLib::Id>;
   }
   static void *newArray_vectorlEClamLibcLcLIdgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::Id>[nElements] : new vector<ClamLib::Id>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEClamLibcLcLIdgR(void *p) {
      delete ((vector<ClamLib::Id>*)p);
   }
   static void deleteArray_vectorlEClamLibcLcLIdgR(void *p) {
      delete [] ((vector<ClamLib::Id>*)p);
   }
   static void destruct_vectorlEClamLibcLcLIdgR(void *p) {
      typedef vector<ClamLib::Id> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ClamLib::Id>

namespace ROOT {
   void vectorlEClamLibcLcLIndexWeightgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEClamLibcLcLIndexWeightgR_Dictionary();
   static void *new_vectorlEClamLibcLcLIndexWeightgR(void *p = 0);
   static void *newArray_vectorlEClamLibcLcLIndexWeightgR(Long_t size, void *p);
   static void delete_vectorlEClamLibcLcLIndexWeightgR(void *p);
   static void deleteArray_vectorlEClamLibcLcLIndexWeightgR(void *p);
   static void destruct_vectorlEClamLibcLcLIndexWeightgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ClamLib::IndexWeight>*)
   {
      vector<ClamLib::IndexWeight> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ClamLib::IndexWeight>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ClamLib::IndexWeight>", -2, "prec_stl/vector", 49,
                  typeid(vector<ClamLib::IndexWeight>), DefineBehavior(ptr, ptr),
                  0, &vectorlEClamLibcLcLIndexWeightgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ClamLib::IndexWeight>) );
      instance.SetNew(&new_vectorlEClamLibcLcLIndexWeightgR);
      instance.SetNewArray(&newArray_vectorlEClamLibcLcLIndexWeightgR);
      instance.SetDelete(&delete_vectorlEClamLibcLcLIndexWeightgR);
      instance.SetDeleteArray(&deleteArray_vectorlEClamLibcLcLIndexWeightgR);
      instance.SetDestructor(&destruct_vectorlEClamLibcLcLIndexWeightgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ClamLib::IndexWeight> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ClamLib::IndexWeight>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEClamLibcLcLIndexWeightgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ClamLib::IndexWeight>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEClamLibcLcLIndexWeightgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::IndexWeight> : new vector<ClamLib::IndexWeight>;
   }
   static void *newArray_vectorlEClamLibcLcLIndexWeightgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::IndexWeight>[nElements] : new vector<ClamLib::IndexWeight>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEClamLibcLcLIndexWeightgR(void *p) {
      delete ((vector<ClamLib::IndexWeight>*)p);
   }
   static void deleteArray_vectorlEClamLibcLcLIndexWeightgR(void *p) {
      delete [] ((vector<ClamLib::IndexWeight>*)p);
   }
   static void destruct_vectorlEClamLibcLcLIndexWeightgR(void *p) {
      typedef vector<ClamLib::IndexWeight> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ClamLib::IndexWeight>

namespace ROOT {
   void vectorlEClamLibcLcLInputOutputPairgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEClamLibcLcLInputOutputPairgR_Dictionary();
   static void *new_vectorlEClamLibcLcLInputOutputPairgR(void *p = 0);
   static void *newArray_vectorlEClamLibcLcLInputOutputPairgR(Long_t size, void *p);
   static void delete_vectorlEClamLibcLcLInputOutputPairgR(void *p);
   static void deleteArray_vectorlEClamLibcLcLInputOutputPairgR(void *p);
   static void destruct_vectorlEClamLibcLcLInputOutputPairgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ClamLib::InputOutputPair>*)
   {
      vector<ClamLib::InputOutputPair> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ClamLib::InputOutputPair>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ClamLib::InputOutputPair>", -2, "prec_stl/vector", 49,
                  typeid(vector<ClamLib::InputOutputPair>), DefineBehavior(ptr, ptr),
                  0, &vectorlEClamLibcLcLInputOutputPairgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ClamLib::InputOutputPair>) );
      instance.SetNew(&new_vectorlEClamLibcLcLInputOutputPairgR);
      instance.SetNewArray(&newArray_vectorlEClamLibcLcLInputOutputPairgR);
      instance.SetDelete(&delete_vectorlEClamLibcLcLInputOutputPairgR);
      instance.SetDeleteArray(&deleteArray_vectorlEClamLibcLcLInputOutputPairgR);
      instance.SetDestructor(&destruct_vectorlEClamLibcLcLInputOutputPairgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ClamLib::InputOutputPair> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ClamLib::InputOutputPair>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEClamLibcLcLInputOutputPairgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ClamLib::InputOutputPair>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEClamLibcLcLInputOutputPairgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::InputOutputPair> : new vector<ClamLib::InputOutputPair>;
   }
   static void *newArray_vectorlEClamLibcLcLInputOutputPairgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::InputOutputPair>[nElements] : new vector<ClamLib::InputOutputPair>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEClamLibcLcLInputOutputPairgR(void *p) {
      delete ((vector<ClamLib::InputOutputPair>*)p);
   }
   static void deleteArray_vectorlEClamLibcLcLInputOutputPairgR(void *p) {
      delete [] ((vector<ClamLib::InputOutputPair>*)p);
   }
   static void destruct_vectorlEClamLibcLcLInputOutputPairgR(void *p) {
      typedef vector<ClamLib::InputOutputPair> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ClamLib::InputOutputPair>

namespace ROOT {
   void vectorlEClamLibcLcLRootLayerDescriptiongR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEClamLibcLcLRootLayerDescriptiongR_Dictionary();
   static void *new_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p = 0);
   static void *newArray_vectorlEClamLibcLcLRootLayerDescriptiongR(Long_t size, void *p);
   static void delete_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p);
   static void deleteArray_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p);
   static void destruct_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ClamLib::RootLayerDescription>*)
   {
      vector<ClamLib::RootLayerDescription> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ClamLib::RootLayerDescription>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ClamLib::RootLayerDescription>", -2, "prec_stl/vector", 49,
                  typeid(vector<ClamLib::RootLayerDescription>), DefineBehavior(ptr, ptr),
                  0, &vectorlEClamLibcLcLRootLayerDescriptiongR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ClamLib::RootLayerDescription>) );
      instance.SetNew(&new_vectorlEClamLibcLcLRootLayerDescriptiongR);
      instance.SetNewArray(&newArray_vectorlEClamLibcLcLRootLayerDescriptiongR);
      instance.SetDelete(&delete_vectorlEClamLibcLcLRootLayerDescriptiongR);
      instance.SetDeleteArray(&deleteArray_vectorlEClamLibcLcLRootLayerDescriptiongR);
      instance.SetDestructor(&destruct_vectorlEClamLibcLcLRootLayerDescriptiongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ClamLib::RootLayerDescription> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ClamLib::RootLayerDescription>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEClamLibcLcLRootLayerDescriptiongR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ClamLib::RootLayerDescription>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::RootLayerDescription> : new vector<ClamLib::RootLayerDescription>;
   }
   static void *newArray_vectorlEClamLibcLcLRootLayerDescriptiongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::RootLayerDescription>[nElements] : new vector<ClamLib::RootLayerDescription>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p) {
      delete ((vector<ClamLib::RootLayerDescription>*)p);
   }
   static void deleteArray_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p) {
      delete [] ((vector<ClamLib::RootLayerDescription>*)p);
   }
   static void destruct_vectorlEClamLibcLcLRootLayerDescriptiongR(void *p) {
      typedef vector<ClamLib::RootLayerDescription> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ClamLib::RootLayerDescription>

namespace ROOT {
   void vectorlEClamLibcLcLSimulationInfoBlockgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEClamLibcLcLSimulationInfoBlockgR_Dictionary();
   static void *new_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p = 0);
   static void *newArray_vectorlEClamLibcLcLSimulationInfoBlockgR(Long_t size, void *p);
   static void delete_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p);
   static void deleteArray_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p);
   static void destruct_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ClamLib::SimulationInfoBlock>*)
   {
      vector<ClamLib::SimulationInfoBlock> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ClamLib::SimulationInfoBlock>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ClamLib::SimulationInfoBlock>", -2, "prec_stl/vector", 49,
                  typeid(vector<ClamLib::SimulationInfoBlock>), DefineBehavior(ptr, ptr),
                  0, &vectorlEClamLibcLcLSimulationInfoBlockgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ClamLib::SimulationInfoBlock>) );
      instance.SetNew(&new_vectorlEClamLibcLcLSimulationInfoBlockgR);
      instance.SetNewArray(&newArray_vectorlEClamLibcLcLSimulationInfoBlockgR);
      instance.SetDelete(&delete_vectorlEClamLibcLcLSimulationInfoBlockgR);
      instance.SetDeleteArray(&deleteArray_vectorlEClamLibcLcLSimulationInfoBlockgR);
      instance.SetDestructor(&destruct_vectorlEClamLibcLcLSimulationInfoBlockgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ClamLib::SimulationInfoBlock> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ClamLib::SimulationInfoBlock>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEClamLibcLcLSimulationInfoBlockgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ClamLib::SimulationInfoBlock>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::SimulationInfoBlock> : new vector<ClamLib::SimulationInfoBlock>;
   }
   static void *newArray_vectorlEClamLibcLcLSimulationInfoBlockgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ClamLib::SimulationInfoBlock>[nElements] : new vector<ClamLib::SimulationInfoBlock>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p) {
      delete ((vector<ClamLib::SimulationInfoBlock>*)p);
   }
   static void deleteArray_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p) {
      delete [] ((vector<ClamLib::SimulationInfoBlock>*)p);
   }
   static void destruct_vectorlEClamLibcLcLSimulationInfoBlockgR(void *p) {
      typedef vector<ClamLib::SimulationInfoBlock> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ClamLib::SimulationInfoBlock>

/********************************************************
* dict.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

extern "C" void G__cpp_reset_tagtabledict();

extern "C" void G__set_cpp_environmentdict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("RootLayeredNetDescription.h");
  G__add_compiledheader("SimulationInfoBlockVector.h");
  G__add_compiledheader("WeightedLink.h");
  G__cpp_reset_tagtabledict();
}
#include <new>
extern "C" int G__cpp_dllrevdict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* ClamLib::RootLayerDescription */
static int G__dict_269_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::RootLayerDescription* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::RootLayerDescription[n];
     } else {
       p = new((void*) gvp) ClamLib::RootLayerDescription[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::RootLayerDescription;
     } else {
       p = new((void*) gvp) ClamLib::RootLayerDescription;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::RootLayerDescription::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::RootLayerDescription::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::RootLayerDescription::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::RootLayerDescription::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::RootLayerDescription*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::RootLayerDescription::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::RootLayerDescription::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::RootLayerDescription::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_269_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::RootLayerDescription::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_269_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::RootLayerDescription* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::RootLayerDescription(*(ClamLib::RootLayerDescription*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::RootLayerDescription G__TClamLibcLcLRootLayerDescription;
static int G__dict_269_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::RootLayerDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::RootLayerDescription*) (soff+(sizeof(ClamLib::RootLayerDescription)*i)))->~G__TClamLibcLcLRootLayerDescription();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::RootLayerDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::RootLayerDescription*) (soff))->~G__TClamLibcLcLRootLayerDescription();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_269_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::RootLayerDescription* dest = (ClamLib::RootLayerDescription*) G__getstructoffset();
   *dest = *(ClamLib::RootLayerDescription*) libp->para[0].ref;
   const ClamLib::RootLayerDescription& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::RootLayeredNetDescription */
static int G__dict_270_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::RootLayeredNetDescription::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::RootLayeredNetDescription::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::RootLayeredNetDescription::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::RootLayeredNetDescription::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::RootLayeredNetDescription*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::RootLayeredNetDescription::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::RootLayeredNetDescription::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::RootLayeredNetDescription::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::RootLayeredNetDescription::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::RootLayeredNetDescription* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::RootLayeredNetDescription[n];
     } else {
       p = new((void*) gvp) ClamLib::RootLayeredNetDescription[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::RootLayeredNetDescription;
     } else {
       p = new((void*) gvp) ClamLib::RootLayeredNetDescription;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::RootLayeredNetDescription* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::RootLayeredNetDescription(*(vector<ClamLib::RootLayerDescription>*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ClamLib::RootLayeredNetDescription(*(vector<ClamLib::RootLayerDescription>*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::RootLayerDescription& obj = ((const ClamLib::RootLayeredNetDescription*) G__getstructoffset())->operator[]((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_270_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ClamLib::RootLayeredNetDescription*) G__getstructoffset())->NumberOfLayers());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_270_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::RootLayeredNetDescription* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::RootLayeredNetDescription(*(ClamLib::RootLayeredNetDescription*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::RootLayeredNetDescription G__TClamLibcLcLRootLayeredNetDescription;
static int G__dict_270_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::RootLayeredNetDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::RootLayeredNetDescription*) (soff+(sizeof(ClamLib::RootLayeredNetDescription)*i)))->~G__TClamLibcLcLRootLayeredNetDescription();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::RootLayeredNetDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::RootLayeredNetDescription*) (soff))->~G__TClamLibcLcLRootLayeredNetDescription();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_270_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::RootLayeredNetDescription* dest = (ClamLib::RootLayeredNetDescription*) G__getstructoffset();
   *dest = *(ClamLib::RootLayeredNetDescription*) libp->para[0].ref;
   const ClamLib::RootLayeredNetDescription& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> > */
static int G__dict_272_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::RootLayerDescription& obj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->at((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator* pobj;
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator xobj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->begin();
         pobj = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator* pobj;
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator xobj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->end();
         pobj = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator* pobj;
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator xobj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->rbegin();
         pobj = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator* pobj;
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator xobj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->rend();
         pobj = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->resize((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->resize((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]), *((ClamLib::RootLayerDescription*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::RootLayerDescription& obj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->operator[]((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >[n];
     } else {
       p = new((void*) gvp) vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >;
     } else {
       p = new((void*) gvp) vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]), *(ClamLib::RootLayerDescription*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]), *(ClamLib::RootLayerDescription*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >(*(vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >(*(vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >(*((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >(*((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >& obj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->operator=(*(vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->reserve((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::RootLayerDescription& obj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::RootLayerDescription& obj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->push_back(*(ClamLib::RootLayerDescription*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->swap(*(vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator* pobj;
         vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator xobj = ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->insert(*((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator*) G__int(libp->para[0])), *(ClamLib::RootLayerDescription*) libp->para[1].ref);
         pobj = new vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->insert(*((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator*) G__int(libp->para[1]))
, *((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->insert(*((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator*) G__int(libp->para[0])), (vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type) G__int(libp->para[1])
, *(ClamLib::RootLayerDescription*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->erase(*((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->erase(*((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_272_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> > G__TvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR;
static int G__dict_272_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) (soff+(sizeof(vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >)*i)))->~G__TvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*) (soff))->~G__TvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::Id */
static int G__dict_281_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::Id* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::Id[n];
     } else {
       p = new((void*) gvp) ClamLib::Id[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::Id;
     } else {
       p = new((void*) gvp) ClamLib::Id;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::Id* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::Id((int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ClamLib::Id((int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::Id& obj = ((ClamLib::Id*) G__getstructoffset())->operator=(*(ClamLib::Id*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::Id::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::Id::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::Id::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::Id::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::Id*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::Id::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::Id::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::Id::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_281_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::Id::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_281_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::Id* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::Id(*(ClamLib::Id*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::Id G__TClamLibcLcLId;
static int G__dict_281_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::Id*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::Id*) (soff+(sizeof(ClamLib::Id)*i)))->~G__TClamLibcLcLId();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::Id*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::Id*) (soff))->~G__TClamLibcLcLId();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::IndexWeight */
static int G__dict_284_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::IndexWeight::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::IndexWeight::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::IndexWeight::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::IndexWeight::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::IndexWeight*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::IndexWeight::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::IndexWeight::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::IndexWeight::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::IndexWeight::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::IndexWeight* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::IndexWeight[n];
     } else {
       p = new((void*) gvp) ClamLib::IndexWeight[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::IndexWeight;
     } else {
       p = new((void*) gvp) ClamLib::IndexWeight;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_284_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::IndexWeight* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::IndexWeight(*(TString*) libp->para[0].ref, (Float_t) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) ClamLib::IndexWeight(*(TString*) libp->para[0].ref, (Float_t) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_284_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::IndexWeight* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::IndexWeight(*(ClamLib::IndexWeight*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::IndexWeight G__TClamLibcLcLIndexWeight;
static int G__dict_284_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::IndexWeight*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::IndexWeight*) (soff+(sizeof(ClamLib::IndexWeight)*i)))->~G__TClamLibcLcLIndexWeight();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::IndexWeight*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::IndexWeight*) (soff))->~G__TClamLibcLcLIndexWeight();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_284_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::IndexWeight* dest = (ClamLib::IndexWeight*) G__getstructoffset();
   *dest = *(ClamLib::IndexWeight*) libp->para[0].ref;
   const ClamLib::IndexWeight& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::CircuitDescription */
static int G__dict_285_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::CircuitDescription::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitDescription::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::CircuitDescription::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::CircuitDescription::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::CircuitDescription*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitDescription::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::CircuitDescription::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitDescription::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::CircuitDescription::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitDescription* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitDescription((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ClamLib::CircuitDescription((UInt_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ClamLib::CircuitDescription[n];
       } else {
         p = new((void*) gvp) ClamLib::CircuitDescription[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ClamLib::CircuitDescription;
       } else {
         p = new((void*) gvp) ClamLib::CircuitDescription;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ClamLib::CircuitDescription*) G__getstructoffset())->push_back(*(ClamLib::CircuitNodeRole*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::CircuitDescription*) G__getstructoffset())->push_back_io(*(ClamLib::InputOutputPair*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitNodeRole& obj = ((const ClamLib::CircuitDescription*) G__getstructoffset())->operator[]((UInt_t) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::CircuitDescription*) G__getstructoffset())->AddExternal((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::CircuitNodeRole>& obj = ((const ClamLib::CircuitDescription*) G__getstructoffset())->RoleVec();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::InputOutputPair>& obj = ((const ClamLib::CircuitDescription*) G__getstructoffset())->IOVec();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ClamLib::CircuitDescription*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ClamLib::CircuitDescription*) G__getstructoffset())->IndexExternal());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_285_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ClamLib::CircuitDescription*) G__getstructoffset())->IndexInCircuitByName((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_285_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::CircuitDescription* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::CircuitDescription(*(ClamLib::CircuitDescription*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::CircuitDescription G__TClamLibcLcLCircuitDescription;
static int G__dict_285_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::CircuitDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::CircuitDescription*) (soff+(sizeof(ClamLib::CircuitDescription)*i)))->~G__TClamLibcLcLCircuitDescription();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::CircuitDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::CircuitDescription*) (soff))->~G__TClamLibcLcLCircuitDescription();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_285_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitDescription* dest = (ClamLib::CircuitDescription*) G__getstructoffset();
   *dest = *(ClamLib::CircuitDescription*) libp->para[0].ref;
   const ClamLib::CircuitDescription& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::CircuitNodeRole */
static int G__dict_286_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::CircuitNodeRole::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitNodeRole::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::CircuitNodeRole::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::CircuitNodeRole::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::CircuitNodeRole*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitNodeRole::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::CircuitNodeRole::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitNodeRole::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::CircuitNodeRole::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitNodeRole* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitNodeRole[n];
     } else {
       p = new((void*) gvp) ClamLib::CircuitNodeRole[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitNodeRole;
     } else {
       p = new((void*) gvp) ClamLib::CircuitNodeRole;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitNodeRole* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 8:
     //m: 8
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitNodeRole(
*(string*) libp->para[0].ref, (UInt_t) G__int(libp->para[1])
, (Float_t) G__double(libp->para[2]), (Float_t) G__double(libp->para[3])
, (Float_t) G__double(libp->para[4]), (Float_t) G__double(libp->para[5])
, (bool) G__int(libp->para[6]), (bool) G__int(libp->para[7]));
     } else {
       p = new((void*) gvp) ClamLib::CircuitNodeRole(
*(string*) libp->para[0].ref, (UInt_t) G__int(libp->para[1])
, (Float_t) G__double(libp->para[2]), (Float_t) G__double(libp->para[3])
, (Float_t) G__double(libp->para[4]), (Float_t) G__double(libp->para[5])
, (bool) G__int(libp->para[6]), (bool) G__int(libp->para[7]));
     }
     break;
   case 7:
     //m: 7
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitNodeRole(
*(string*) libp->para[0].ref, (UInt_t) G__int(libp->para[1])
, (Float_t) G__double(libp->para[2]), (Float_t) G__double(libp->para[3])
, (Float_t) G__double(libp->para[4]), (Float_t) G__double(libp->para[5])
, (bool) G__int(libp->para[6]));
     } else {
       p = new((void*) gvp) ClamLib::CircuitNodeRole(
*(string*) libp->para[0].ref, (UInt_t) G__int(libp->para[1])
, (Float_t) G__double(libp->para[2]), (Float_t) G__double(libp->para[3])
, (Float_t) G__double(libp->para[4]), (Float_t) G__double(libp->para[5])
, (bool) G__int(libp->para[6]));
     }
     break;
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitNodeRole(
*(string*) libp->para[0].ref, (UInt_t) G__int(libp->para[1])
, (Float_t) G__double(libp->para[2]), (Float_t) G__double(libp->para[3])
, (Float_t) G__double(libp->para[4]), (Float_t) G__double(libp->para[5]));
     } else {
       p = new((void*) gvp) ClamLib::CircuitNodeRole(
*(string*) libp->para[0].ref, (UInt_t) G__int(libp->para[1])
, (Float_t) G__double(libp->para[2]), (Float_t) G__double(libp->para[3])
, (Float_t) G__double(libp->para[4]), (Float_t) G__double(libp->para[5]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitNodeRole* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::CircuitNodeRole(*(ClamLib::CircuitNodeRole*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ClamLib::CircuitNodeRole(*(ClamLib::CircuitNodeRole*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ClamLib::CircuitNodeRole*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DynamicLib::SpatialPosition* pobj;
         const DynamicLib::SpatialPosition xobj = ((const ClamLib::CircuitNodeRole*) G__getstructoffset())->Position();
         pobj = new DynamicLib::SpatialPosition(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::IndexWeight& obj = ((const ClamLib::CircuitNodeRole*) G__getstructoffset())->operator[]((UInt_t) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::IndexWeight>& obj = ((const ClamLib::CircuitNodeRole*) G__getstructoffset())->IncomingVec();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ClamLib::CircuitNodeRole*) G__getstructoffset())->Type());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ClamLib::CircuitNodeRole*) G__getstructoffset())->AddIncoming(*((ClamLib::IndexWeight*) G__int(libp->para[0]))));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ClamLib::CircuitNodeRole*) G__getstructoffset())->isOutput());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_286_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ClamLib::CircuitNodeRole*) G__getstructoffset())->isPositive());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::CircuitNodeRole G__TClamLibcLcLCircuitNodeRole;
static int G__dict_286_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::CircuitNodeRole*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::CircuitNodeRole*) (soff+(sizeof(ClamLib::CircuitNodeRole)*i)))->~G__TClamLibcLcLCircuitNodeRole();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::CircuitNodeRole*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::CircuitNodeRole*) (soff))->~G__TClamLibcLcLCircuitNodeRole();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_286_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitNodeRole* dest = (ClamLib::CircuitNodeRole*) G__getstructoffset();
   *dest = *(ClamLib::CircuitNodeRole*) libp->para[0].ref;
   const ClamLib::CircuitNodeRole& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> > */
static int G__dict_288_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::IndexWeight& obj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->at((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator* pobj;
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator xobj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->begin();
         pobj = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator* pobj;
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator xobj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->end();
         pobj = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator* pobj;
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator xobj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->rbegin();
         pobj = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator* pobj;
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator xobj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->rend();
         pobj = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->resize((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->resize((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]), *((ClamLib::IndexWeight*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::IndexWeight& obj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->operator[]((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >[n];
     } else {
       p = new((void*) gvp) vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >;
     } else {
       p = new((void*) gvp) vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]), *(ClamLib::IndexWeight*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]), *(ClamLib::IndexWeight*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >(*(vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >(*(vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >(*((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >(*((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >& obj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->operator=(*(vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->reserve((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::IndexWeight& obj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::IndexWeight& obj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->push_back(*(ClamLib::IndexWeight*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->swap(*(vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator* pobj;
         vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator xobj = ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->insert(*((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator*) G__int(libp->para[0])), *(ClamLib::IndexWeight*) libp->para[1].ref);
         pobj = new vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->insert(*((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator*) G__int(libp->para[1]))
, *((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->insert(*((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator*) G__int(libp->para[0])), (vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type) G__int(libp->para[1])
, *(ClamLib::IndexWeight*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->erase(*((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->erase(*((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_288_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> > G__TvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR;
static int G__dict_288_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) (soff+(sizeof(vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >)*i)))->~G__TvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*) (soff))->~G__TvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::InputOutputPair */
static int G__dict_297_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::InputOutputPair::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::InputOutputPair::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::InputOutputPair::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::InputOutputPair::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::InputOutputPair*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::InputOutputPair::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::InputOutputPair::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::InputOutputPair::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::InputOutputPair::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_297_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::InputOutputPair* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::InputOutputPair[n];
     } else {
       p = new((void*) gvp) ClamLib::InputOutputPair[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::InputOutputPair;
     } else {
       p = new((void*) gvp) ClamLib::InputOutputPair;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_297_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::InputOutputPair* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::InputOutputPair(*(ClamLib::InputOutputPair*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::InputOutputPair G__TClamLibcLcLInputOutputPair;
static int G__dict_297_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::InputOutputPair*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::InputOutputPair*) (soff+(sizeof(ClamLib::InputOutputPair)*i)))->~G__TClamLibcLcLInputOutputPair();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::InputOutputPair*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::InputOutputPair*) (soff))->~G__TClamLibcLcLInputOutputPair();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_297_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::InputOutputPair* dest = (ClamLib::InputOutputPair*) G__getstructoffset();
   *dest = *(ClamLib::InputOutputPair*) libp->para[0].ref;
   const ClamLib::InputOutputPair& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> > */
static int G__dict_299_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitNodeRole& obj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->at((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator* pobj;
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator xobj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->begin();
         pobj = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator* pobj;
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator xobj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->end();
         pobj = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator* pobj;
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator xobj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->rbegin();
         pobj = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator* pobj;
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator xobj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->rend();
         pobj = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->resize((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->resize((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]), *((ClamLib::CircuitNodeRole*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitNodeRole& obj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->operator[]((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >[n];
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >;
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]), *(ClamLib::CircuitNodeRole*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]), *(ClamLib::CircuitNodeRole*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >(*(vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >(*(vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >(*((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >(*((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >& obj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->operator=(*(vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->reserve((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitNodeRole& obj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitNodeRole& obj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->push_back(*(ClamLib::CircuitNodeRole*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->swap(*(vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator* pobj;
         vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator xobj = ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->insert(*((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator*) G__int(libp->para[0])), *(ClamLib::CircuitNodeRole*) libp->para[1].ref);
         pobj = new vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->insert(*((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator*) G__int(libp->para[1]))
, *((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->insert(*((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator*) G__int(libp->para[0])), (vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type) G__int(libp->para[1])
, *(ClamLib::CircuitNodeRole*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->erase(*((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->erase(*((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_299_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> > G__TvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR;
static int G__dict_299_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) (soff+(sizeof(vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >)*i)))->~G__TvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*) (soff))->~G__TvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> > */
static int G__dict_309_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::InputOutputPair& obj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->at((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator* pobj;
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator xobj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->begin();
         pobj = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator* pobj;
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator xobj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->end();
         pobj = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator* pobj;
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator xobj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->rbegin();
         pobj = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator* pobj;
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator xobj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->rend();
         pobj = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->resize((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->resize((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]), *((ClamLib::InputOutputPair*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::InputOutputPair& obj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->operator[]((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >[n];
     } else {
       p = new((void*) gvp) vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >;
     } else {
       p = new((void*) gvp) vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]), *(ClamLib::InputOutputPair*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]), *(ClamLib::InputOutputPair*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >(*(vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >(*(vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >(*((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >(*((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >& obj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->operator=(*(vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->reserve((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::InputOutputPair& obj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::InputOutputPair& obj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->push_back(*(ClamLib::InputOutputPair*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->swap(*(vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator* pobj;
         vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator xobj = ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->insert(*((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator*) G__int(libp->para[0])), *(ClamLib::InputOutputPair*) libp->para[1].ref);
         pobj = new vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->insert(*((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator*) G__int(libp->para[1]))
, *((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->insert(*((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator*) G__int(libp->para[0])), (vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type) G__int(libp->para[1])
, *(ClamLib::InputOutputPair*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->erase(*((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->erase(*((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_309_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> > G__TvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR;
static int G__dict_309_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) (soff+(sizeof(vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >)*i)))->~G__TvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*) (soff))->~G__TvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::CircuitInfo */
static int G__dict_318_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::CircuitInfo::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitInfo::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::CircuitInfo::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::CircuitInfo::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::CircuitInfo*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitInfo::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::CircuitInfo::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::CircuitInfo::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::CircuitInfo::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitInfo* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitInfo[n];
     } else {
       p = new((void*) gvp) ClamLib::CircuitInfo[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::CircuitInfo;
     } else {
       p = new((void*) gvp) ClamLib::CircuitInfo;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::Id* pobj;
         const ClamLib::Id xobj = ((const ClamLib::CircuitInfo*) G__getstructoffset())->ExternalInputId();
         pobj = new ClamLib::Id(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::Id& obj = ((ClamLib::CircuitInfo*) G__getstructoffset())->operator[]((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::Id& obj = ((const ClamLib::CircuitInfo*) G__getstructoffset())->operator[]((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::Id& obj = ((const ClamLib::CircuitInfo*) G__getstructoffset())->IdOriginal();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::CircuitInfo*) G__getstructoffset())->Reserve((const char*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *((ClamLib::Id*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ClamLib::CircuitInfo*) G__getstructoffset())->NumberOfNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_318_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::CircuitInfo*) G__getstructoffset())->SetExternal(*((ClamLib::Id*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_318_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::CircuitInfo* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::CircuitInfo(*(ClamLib::CircuitInfo*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::CircuitInfo G__TClamLibcLcLCircuitInfo;
static int G__dict_318_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::CircuitInfo*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::CircuitInfo*) (soff+(sizeof(ClamLib::CircuitInfo)*i)))->~G__TClamLibcLcLCircuitInfo();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::CircuitInfo*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::CircuitInfo*) (soff))->~G__TClamLibcLcLCircuitInfo();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_318_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::CircuitInfo* dest = (ClamLib::CircuitInfo*) G__getstructoffset();
   *dest = *(ClamLib::CircuitInfo*) libp->para[0].ref;
   const ClamLib::CircuitInfo& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::SimulationInfoBlock */
static int G__dict_330_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::SimulationInfoBlock::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::SimulationInfoBlock::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::SimulationInfoBlock::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::SimulationInfoBlock::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::SimulationInfoBlock*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::SimulationInfoBlock::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::SimulationInfoBlock::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::SimulationInfoBlock::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::SimulationInfoBlock::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlock* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::SimulationInfoBlock[n];
     } else {
       p = new((void*) gvp) ClamLib::SimulationInfoBlock[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::SimulationInfoBlock;
     } else {
       p = new((void*) gvp) ClamLib::SimulationInfoBlock;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlock* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::SimulationInfoBlock(*(ClamLib::SimulationInfoBlock*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ClamLib::SimulationInfoBlock(*(ClamLib::SimulationInfoBlock*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlock* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::SimulationInfoBlock(*(ClamLib::DynamicSubNetwork*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ClamLib::SimulationInfoBlock(*(ClamLib::DynamicSubNetwork*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlock* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::SimulationInfoBlock(
*(TString*) libp->para[0].ref, *(ClamLib::RootLayeredNetDescription*) libp->para[1].ref
, *(vector<ClamLib::CircuitInfo>*) libp->para[2].ref, *(ClamLib::CircuitDescription*) libp->para[3].ref);
   } else {
     p = new((void*) gvp) ClamLib::SimulationInfoBlock(
*(TString*) libp->para[0].ref, *(ClamLib::RootLayeredNetDescription*) libp->para[1].ref
, *(vector<ClamLib::CircuitInfo>*) libp->para[2].ref, *(ClamLib::CircuitDescription*) libp->para[3].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const ClamLib::SimulationInfoBlock*) G__getstructoffset())->Name();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::CircuitInfo>& obj = ((const ClamLib::SimulationInfoBlock*) G__getstructoffset())->InfoVector();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::RootLayeredNetDescription& obj = ((const ClamLib::SimulationInfoBlock*) G__getstructoffset())->DescriptionVector();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_330_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitDescription& obj = ((const ClamLib::SimulationInfoBlock*) G__getstructoffset())->DescriptionCircuit();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::SimulationInfoBlock G__TClamLibcLcLSimulationInfoBlock;
static int G__dict_330_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::SimulationInfoBlock*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::SimulationInfoBlock*) (soff+(sizeof(ClamLib::SimulationInfoBlock)*i)))->~G__TClamLibcLcLSimulationInfoBlock();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::SimulationInfoBlock*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::SimulationInfoBlock*) (soff))->~G__TClamLibcLcLSimulationInfoBlock();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_330_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlock* dest = (ClamLib::SimulationInfoBlock*) G__getstructoffset();
   *dest = *(ClamLib::SimulationInfoBlock*) libp->para[0].ref;
   const ClamLib::SimulationInfoBlock& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> > */
static int G__dict_332_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitInfo& obj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->at((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator* pobj;
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator xobj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->begin();
         pobj = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator* pobj;
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator xobj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->end();
         pobj = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator* pobj;
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator xobj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->rbegin();
         pobj = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator* pobj;
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator xobj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->rend();
         pobj = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->resize((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->resize((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]), *((ClamLib::CircuitInfo*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitInfo& obj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->operator[]((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >[n];
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >;
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]), *(ClamLib::CircuitInfo*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]), *(ClamLib::CircuitInfo*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >(*(vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >(*(vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >(*((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >(*((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >& obj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->operator=(*(vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->reserve((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitInfo& obj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::CircuitInfo& obj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->push_back(*(ClamLib::CircuitInfo*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->swap(*(vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator* pobj;
         vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator xobj = ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->insert(*((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator*) G__int(libp->para[0])), *(ClamLib::CircuitInfo*) libp->para[1].ref);
         pobj = new vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->insert(*((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator*) G__int(libp->para[1]))
, *((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->insert(*((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator*) G__int(libp->para[0])), (vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type) G__int(libp->para[1])
, *(ClamLib::CircuitInfo*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->erase(*((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->erase(*((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_332_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> > G__TvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR;
static int G__dict_332_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) (soff+(sizeof(vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >)*i)))->~G__TvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*) (soff))->~G__TvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ClamLib::SimulationInfoBlockVector */
static int G__dict_341_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ClamLib::SimulationInfoBlockVector::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::SimulationInfoBlockVector::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) ClamLib::SimulationInfoBlockVector::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ClamLib::SimulationInfoBlockVector::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ClamLib::SimulationInfoBlockVector*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::SimulationInfoBlockVector::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::SimulationInfoBlockVector::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ClamLib::SimulationInfoBlockVector::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ClamLib::SimulationInfoBlockVector::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlockVector* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::SimulationInfoBlockVector[n];
     } else {
       p = new((void*) gvp) ClamLib::SimulationInfoBlockVector[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ClamLib::SimulationInfoBlockVector;
     } else {
       p = new((void*) gvp) ClamLib::SimulationInfoBlockVector;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlockVector* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ClamLib::SimulationInfoBlockVector(*(vector<ClamLib::SimulationInfoBlock>*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ClamLib::SimulationInfoBlockVector(*(vector<ClamLib::SimulationInfoBlock>*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ClamLib::SimulationInfoBlockVector*) G__getstructoffset())->NumberOfBlocks());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_341_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::SimulationInfoBlock>& obj = ((const ClamLib::SimulationInfoBlockVector*) G__getstructoffset())->BlockVector();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_341_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ClamLib::SimulationInfoBlockVector* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ClamLib::SimulationInfoBlockVector(*(ClamLib::SimulationInfoBlockVector*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ClamLib::SimulationInfoBlockVector G__TClamLibcLcLSimulationInfoBlockVector;
static int G__dict_341_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ClamLib::SimulationInfoBlockVector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ClamLib::SimulationInfoBlockVector*) (soff+(sizeof(ClamLib::SimulationInfoBlockVector)*i)))->~G__TClamLibcLcLSimulationInfoBlockVector();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ClamLib::SimulationInfoBlockVector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ClamLib::SimulationInfoBlockVector*) (soff))->~G__TClamLibcLcLSimulationInfoBlockVector();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_341_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ClamLib::SimulationInfoBlockVector* dest = (ClamLib::SimulationInfoBlockVector*) G__getstructoffset();
   *dest = *(ClamLib::SimulationInfoBlockVector*) libp->para[0].ref;
   const ClamLib::SimulationInfoBlockVector& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> > */
static int G__dict_343_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::SimulationInfoBlock& obj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->at((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator* pobj;
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator xobj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->begin();
         pobj = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator* pobj;
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator xobj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->end();
         pobj = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator* pobj;
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator xobj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->rbegin();
         pobj = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator* pobj;
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator xobj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->rend();
         pobj = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->resize((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->resize((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]), *((ClamLib::SimulationInfoBlock*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::SimulationInfoBlock& obj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->operator[]((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >[n];
     } else {
       p = new((void*) gvp) vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >;
     } else {
       p = new((void*) gvp) vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]), *(ClamLib::SimulationInfoBlock*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]), *(ClamLib::SimulationInfoBlock*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >(*(vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >(*(vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >(*((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >(*((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator*) G__int(libp->para[0])), *((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >& obj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->operator=(*(vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->reserve((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::SimulationInfoBlock& obj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ClamLib::SimulationInfoBlock& obj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->push_back(*(ClamLib::SimulationInfoBlock*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->swap(*(vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator* pobj;
         vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator xobj = ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->insert(*((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator*) G__int(libp->para[0])), *(ClamLib::SimulationInfoBlock*) libp->para[1].ref);
         pobj = new vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->insert(*((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator*) G__int(libp->para[1]))
, *((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->insert(*((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator*) G__int(libp->para[0])), (vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type) G__int(libp->para[1])
, *(ClamLib::SimulationInfoBlock*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->erase(*((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->erase(*((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator*) G__int(libp->para[0])), *((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_343_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> > G__TvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR;
static int G__dict_343_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) (soff+(sizeof(vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >)*i)))->~G__TvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*) (soff))->~G__TvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* WeightedLink<double> */
static int G__dict_352_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) WeightedLink<double>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) WeightedLink<double>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) WeightedLink<double>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      WeightedLink<double>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((WeightedLink<double>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) WeightedLink<double>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) WeightedLink<double>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) WeightedLink<double>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) WeightedLink<double>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   WeightedLink<double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new WeightedLink<double>[n];
     } else {
       p = new((void*) gvp) WeightedLink<double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new WeightedLink<double>;
     } else {
       p = new((void*) gvp) WeightedLink<double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__dict_352_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   WeightedLink<double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new WeightedLink<double>(
*((ClamLib::Id*) G__int(libp->para[0])), *((ClamLib::Id*) G__int(libp->para[1]))
, (double) G__double(libp->para[2]));
   } else {
     p = new((void*) gvp) WeightedLink<double>(
*((ClamLib::Id*) G__int(libp->para[0])), *((ClamLib::Id*) G__int(libp->para[1]))
, (double) G__double(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__dict_352_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   WeightedLink<double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new WeightedLink<double>(*(WeightedLink<double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef WeightedLink<double> G__TWeightedLinklEdoublegR;
static int G__dict_352_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (WeightedLink<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((WeightedLink<double>*) (soff+(sizeof(WeightedLink<double>)*i)))->~G__TWeightedLinklEdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (WeightedLink<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((WeightedLink<double>*) (soff))->~G__TWeightedLinklEdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__dict_352_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   WeightedLink<double>* dest = (WeightedLink<double>*) G__getstructoffset();
   *dest = *(WeightedLink<double>*) libp->para[0].ref;
   const WeightedLink<double>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* ClamLib::RootLayerDescription */

/* ClamLib::RootLayeredNetDescription */

/* vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> > */

/* ClamLib::Id */

/* ClamLib::IndexWeight */

/* ClamLib::CircuitDescription */

/* ClamLib::CircuitNodeRole */

/* vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> > */

/* ClamLib::InputOutputPair */

/* vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> > */

/* vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> > */

/* ClamLib::CircuitInfo */

/* ClamLib::SimulationInfoBlock */

/* vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> > */

/* ClamLib::SimulationInfoBlockVector */

/* vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> > */

/* WeightedLink<double> */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncdict {
 public:
  G__Sizep2memfuncdict(): p(&G__Sizep2memfuncdict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncdict::*p)();
};

size_t G__get_sizep2memfuncdict()
{
  G__Sizep2memfuncdict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritancedict() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription))) {
     ClamLib::RootLayerDescription *G__Lderived;
     G__Lderived=(ClamLib::RootLayerDescription*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription))) {
     ClamLib::RootLayeredNetDescription *G__Lderived;
     G__Lderived=(ClamLib::RootLayeredNetDescription*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId))) {
     ClamLib::Id *G__Lderived;
     G__Lderived=(ClamLib::Id*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight))) {
     ClamLib::IndexWeight *G__Lderived;
     G__Lderived=(ClamLib::IndexWeight*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription))) {
     ClamLib::CircuitDescription *G__Lderived;
     G__Lderived=(ClamLib::CircuitDescription*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole))) {
     ClamLib::CircuitNodeRole *G__Lderived;
     G__Lderived=(ClamLib::CircuitNodeRole*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair))) {
     ClamLib::InputOutputPair *G__Lderived;
     G__Lderived=(ClamLib::InputOutputPair*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo))) {
     ClamLib::CircuitInfo *G__Lderived;
     G__Lderived=(ClamLib::CircuitInfo*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock))) {
     ClamLib::SimulationInfoBlock *G__Lderived;
     G__Lderived=(ClamLib::SimulationInfoBlock*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector))) {
     ClamLib::SimulationInfoBlockVector *G__Lderived;
     G__Lderived=(ClamLib::SimulationInfoBlockVector*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR))) {
     WeightedLink<double> *G__Lderived;
     G__Lderived=(WeightedLink<double>*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR),G__get_linked_tagnum(&G__dictLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR),G__get_linked_tagnum(&G__dictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetabledict() {

   /* Setting up typedef entry */
   G__search_typename2("UInt_t",104,-1,0,-1);
   G__setnewtype(-1,"Unsigned integer 4 bytes (unsigned int)",0);
   G__search_typename2("Float_t",102,-1,0,-1);
   G__setnewtype(-1,"Float 4 bytes (float)",0);
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ROOT::TSchemaHelper,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::iterator_category,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::value_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::difference_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::pointer,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ROOT::TSchemaHelper,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ROOT::TSchemaHelper,long,ROOT::TSchemaHelper*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::iterator_category,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::value_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::difference_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::pointer,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<TVirtualArray*,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlETVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::iterator_category,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::value_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::difference_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::pointer,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,TVirtualArray*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,TVirtualArray*,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,TVirtualArray*,long,TVirtualArray**>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::iterator_category,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::value_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::difference_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::pointer,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::RootLayerDescription>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ClamLib::RootLayerDescription,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::RootLayerDescription>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator>::iterator_category,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator>::value_type,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator>::difference_type,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator>::pointer,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::RootLayerDescription>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::RootLayerDescription,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::RootLayerDescription,long,ClamLib::RootLayerDescription*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator>::iterator_category,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator>::value_type,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator>::difference_type,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator>::pointer,iterator_traits<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::IndexWeight>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ClamLib::IndexWeight,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::IndexWeight>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator>::iterator_category,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator>::value_type,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator>::difference_type,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator>::pointer,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::IndexWeight>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::IndexWeight,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::IndexWeight,long,ClamLib::IndexWeight*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator>::iterator_category,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator>::value_type,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator>::difference_type,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator>::pointer,iterator_traits<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::CircuitNodeRole>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ClamLib::CircuitNodeRole,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::CircuitNodeRole>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator>::iterator_category,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator>::value_type,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator>::difference_type,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator>::pointer,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::CircuitNodeRole>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::CircuitNodeRole,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::CircuitNodeRole,long,ClamLib::CircuitNodeRole*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator>::iterator_category,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator>::value_type,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator>::difference_type,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator>::pointer,iterator_traits<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::InputOutputPair>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ClamLib::InputOutputPair,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::InputOutputPair>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator>::iterator_category,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator>::value_type,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator>::difference_type,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator>::pointer,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::InputOutputPair>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::InputOutputPair,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::InputOutputPair,long,ClamLib::InputOutputPair*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator>::iterator_category,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator>::value_type,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator>::difference_type,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator>::pointer,iterator_traits<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Id>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ClamLib::Id,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::Id>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::iterator>::iterator_category,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::iterator>::value_type,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::iterator>::difference_type,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::iterator>::pointer,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::Id>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::Id,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::Id,long,ClamLib::Id*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::const_iterator>::iterator_category,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::const_iterator>::value_type,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::const_iterator>::difference_type,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::const_iterator>::pointer,iterator_traits<vector<ClamLib::Id,allocator<ClamLib::Id> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::CircuitInfo>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ClamLib::CircuitInfo,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::CircuitInfo>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator>::iterator_category,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator>::value_type,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator>::difference_type,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator>::pointer,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::CircuitInfo>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::CircuitInfo,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::CircuitInfo,long,ClamLib::CircuitInfo*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator>::iterator_category,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator>::value_type,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator>::difference_type,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator>::pointer,iterator_traits<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::SimulationInfoBlock>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock),1,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("_Ranit<ClamLib::SimulationInfoBlock,difference_type,const_pointer,const_reference>",117,G__get_linked_tagnum(&G__dictLN__RanitlEClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ClamLib::SimulationInfoBlock>",117,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator>::iterator_category,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator>::value_type,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator>::difference_type,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator>::pointer,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::SimulationInfoBlock>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::SimulationInfoBlock,long>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ClamLib::SimulationInfoBlock,long,ClamLib::SimulationInfoBlock*>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator>::iterator_category,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator>::value_type,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator>::difference_type,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator>::pointer,iterator_traits<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* ClamLib::RootLayerDescription */
static void G__setup_memvarClamLibcLcLRootLayerDescription(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription));
   { ClamLib::RootLayerDescription *p; p=(ClamLib::RootLayerDescription*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->_nr_x_pixels)-(long)(p)),104,0,0,-1,-1,-1,1,"_nr_x_pixels=",0,"*!< nr. neurons in x								*/");
   G__memvar_setup((void*)((long)(&p->_nr_y_pixels)-(long)(p)),104,0,0,-1,-1,-1,1,"_nr_y_pixels=",0,"*!< nr. neurons in y								*/");
   G__memvar_setup((void*)((long)(&p->_nr_features)-(long)(p)),104,0,0,-1,-1,-1,1,"_nr_features=",0,"*!< nr. of 'feature' or 'orientation' layers		*/");
   G__memvar_setup((void*)((long)(&p->_size_receptive_field_x)-(long)(p)),104,0,0,-1,-1,-1,1,"_size_receptive_field_x=",0,"*!< size of receptive field in x for this layer	*/	");
   G__memvar_setup((void*)((long)(&p->_size_receptive_field_y)-(long)(p)),104,0,0,-1,-1,-1,1,"_size_receptive_field_y=",0,"*!< size of receptive field in y for this layer	*/");
   G__memvar_setup((void*)((long)(&p->_nr_x_skips)-(long)(p)),104,0,0,-1,-1,-1,1,"_nr_x_skips=",0,"*!< nr. of 'skips' in x :must NOT be zero			*/");
   G__memvar_setup((void*)((long)(&p->_nr_y_skips)-(long)(p)),104,0,0,-1,-1,-1,1,"_nr_y_skips=",0,"/!< nr. of 'skips' in y : must NOT be zero		*/");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ClamLib::RootLayeredNetDescription */
static void G__setup_memvarClamLibcLcLRootLayeredNetDescription(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription));
   { ClamLib::RootLayeredNetDescription *p; p=(ClamLib::RootLayeredNetDescription*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR),G__defined_typename("vector<ClamLib::RootLayerDescription>"),-1,4,"_vec_desc=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> > */
static void G__setup_memvarvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   { vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> > *p; p=(vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ClamLib::Id */
static void G__setup_memvarClamLibcLcLId(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId));
   { ClamLib::Id *p; p=(ClamLib::Id*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->_id_value)-(long)(p)),105,0,0,-1,-1,-1,1,"_id_value=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ClamLib::IndexWeight */
static void G__setup_memvarClamLibcLcLIndexWeight(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight));
   { ClamLib::IndexWeight *p; p=(ClamLib::IndexWeight*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_name_predecessor)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__dictLN_TString),-1,-1,1,"_name_predecessor=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_weight)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"_weight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_index)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"_index=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ClamLib::CircuitDescription */
static void G__setup_memvarClamLibcLcLCircuitDescription(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription));
   { ClamLib::CircuitDescription *p; p=(ClamLib::CircuitDescription*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"_b_is_setup=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"_nr_nodes=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"_index=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR),G__defined_typename("vector<ClamLib::CircuitNodeRole>"),-1,4,"_vec_role=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR),G__defined_typename("vector<ClamLib::InputOutputPair>"),-1,4,"_vec_io=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_TString),-1,-1,4,"_name_external=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"_index_external=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ClamLib::CircuitNodeRole */
static void G__setup_memvarClamLibcLcLCircuitNodeRole(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole));
   { ClamLib::CircuitNodeRole *p; p=(ClamLib::CircuitNodeRole*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"_type=",0,"EXCITATORY or INHIBITORY");
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"_x=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"_y=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"_z=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"_f=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"_isOutput=",0,"If this node is an output node");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"_isPositive=",0,"If node output is considered a positive value");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR),G__defined_typename("vector<ClamLib::IndexWeight>"),-1,4,"_incoming=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> > */
static void G__setup_memvarvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   { vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> > *p; p=(vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ClamLib::InputOutputPair */
static void G__setup_memvarClamLibcLcLInputOutputPair(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair));
   { ClamLib::InputOutputPair *p; p=(ClamLib::InputOutputPair*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_id_in)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"_id_in=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_id_out)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"_id_out=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> > */
static void G__setup_memvarvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   { vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> > *p; p=(vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> > */
static void G__setup_memvarvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   { vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> > *p; p=(vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ClamLib::CircuitInfo */
static void G__setup_memvarClamLibcLcLCircuitInfo(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo));
   { ClamLib::CircuitInfo *p; p=(ClamLib::CircuitInfo*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId),-1,-1,4,"_id_ann=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId),-1,-1,4,"_id_external=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR),G__defined_typename("vector<Id>"),-1,4,"_vec_id=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ClamLib::SimulationInfoBlock */
static void G__setup_memvarClamLibcLcLSimulationInfoBlock(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock));
   { ClamLib::SimulationInfoBlock *p; p=(ClamLib::SimulationInfoBlock*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_TString),-1,-1,4,"_name=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription),-1,-1,4,"_net_desc=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR),G__defined_typename("vector<ClamLib::CircuitInfo>"),-1,4,"_info=",0,"namespace is necessary, due to a bug in CINT (root 5.17)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription),-1,-1,4,"_circ_desc=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> > */
static void G__setup_memvarvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   { vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> > *p; p=(vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ClamLib::SimulationInfoBlockVector */
static void G__setup_memvarClamLibcLcLSimulationInfoBlockVector(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector));
   { ClamLib::SimulationInfoBlockVector *p; p=(ClamLib::SimulationInfoBlockVector*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR),G__defined_typename("vector<ClamLib::SimulationInfoBlock>"),-1,4,"_vec_info=",0,"namespace is necessary, due to a bug in CINT (root 5.17)");
   }
   G__tag_memvar_reset();
}


   /* vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> > */
static void G__setup_memvarvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   { vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> > *p; p=(vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* WeightedLink<double> */
static void G__setup_memvarWeightedLinklEdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR));
   { WeightedLink<double> *p; p=(WeightedLink<double>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__dictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_id_from)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId),-1,-1,1,"_id_from=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_id_to)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId),-1,-1,1,"_id_to=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->_weight)-(long)(p)),100,0,0,-1,-1,-1,1,"_weight=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvardict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncClamLibcLcLRootLayerDescription(void) {
   /* ClamLib::RootLayerDescription */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription));
   G__memfunc_setup("RootLayerDescription",2085,G__dict_269_0_1, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__dict_269_0_2, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::RootLayerDescription::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_269_0_3, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::RootLayerDescription::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_269_0_4, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::RootLayerDescription::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_269_0_5, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::RootLayerDescription::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_269_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_269_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::RootLayerDescription::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_269_0_11, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::RootLayerDescription::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_269_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::RootLayerDescription::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_269_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::RootLayerDescription::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("RootLayerDescription", 2085, G__dict_269_0_14, (int) ('i'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 0, 1, 1, 1, 0, "u 'ClamLib::RootLayerDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RootLayerDescription", 2211, G__dict_269_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_269_0_16, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 1, 1, 1, 1, 0, "u 'ClamLib::RootLayerDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLRootLayeredNetDescription(void) {
   /* ClamLib::RootLayeredNetDescription */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription));
   G__memfunc_setup("Class",502,G__dict_270_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::RootLayeredNetDescription::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_270_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::RootLayeredNetDescription::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_270_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::RootLayeredNetDescription::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_270_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::RootLayeredNetDescription::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_270_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_270_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::RootLayeredNetDescription::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_270_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::RootLayeredNetDescription::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_270_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::RootLayeredNetDescription::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_270_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::RootLayeredNetDescription::DeclFileLine) ), 0);
   G__memfunc_setup("RootLayeredNetDescription",2581,G__dict_270_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RootLayeredNetDescription",2581,G__dict_270_0_14, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >' 'vector<ClamLib::RootLayerDescription>' 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_270_0_15, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 1, 1, 1, 1, 9, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NumberOfLayers",1422,G__dict_270_0_16, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RootLayeredNetDescription", 2581, G__dict_270_0_17, (int) ('i'), 
G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription), -1, 0, 1, 1, 1, 0, "u 'ClamLib::RootLayeredNetDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RootLayeredNetDescription", 2707, G__dict_270_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_270_0_19, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription), -1, 1, 1, 1, 1, 0, "u 'ClamLib::RootLayeredNetDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR(void) {
   /* vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR));
   G__memfunc_setup("at",213,G__dict_272_0_1, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__dict_272_0_2, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__dict_272_0_3, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__dict_272_0_4, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__dict_272_0_5, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_272_0_6, 104, -1, G__defined_typename("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__dict_272_0_7, 104, -1, G__defined_typename("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_272_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_272_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type' 0 - sz u 'ClamLib::RootLayerDescription' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__dict_272_0_10, 104, -1, G__defined_typename("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__dict_272_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_272_0_12, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >",7662,G__dict_272_0_13, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >",7662,G__dict_272_0_14, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type' 0 - n u 'ClamLib::RootLayerDescription' - 11 'ClamLib::RootLayerDescription()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >",7662,G__dict_272_0_15, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >",7662,G__dict_272_0_16, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator' - 0 - first u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__dict_272_0_17, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__dict_272_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__dict_272_0_19, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__dict_272_0_20, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayerDescription), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__dict_272_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::RootLayerDescription' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__dict_272_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_272_0_23, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator' - 0 - position u 'ClamLib::RootLayerDescription' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_272_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator' - 0 - position u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator' - 0 - first "
"u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_272_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator' - 0 - position h - 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::size_type' 0 - n "
"u 'ClamLib::RootLayerDescription' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__dict_272_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_272_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_272_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator' - 0 - first u 'vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__dict_272_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >", 7788, G__dict_272_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLId(void) {
   /* ClamLib::Id */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId));
   G__memfunc_setup("Id",173,G__dict_281_0_1, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 0, 0, 5, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Id",173,G__dict_281_0_2, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 0, 1, 5, 1, 0, "i - - 0 - id_value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__dict_281_0_3, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 1, 1, 1, 1, 0, "u 'ClamLib::Id' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__dict_281_0_4, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::Id::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_281_0_5, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::Id::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_281_0_6, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::Id::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_281_0_7, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::Id::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_281_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_281_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::Id::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_281_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::Id::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_281_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::Id::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_281_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::Id::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("Id", 173, G__dict_281_0_16, (int) ('i'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 0, 1, 1, 1, 0, "u 'ClamLib::Id' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Id", 299, G__dict_281_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLIndexWeight(void) {
   /* ClamLib::IndexWeight */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight));
   G__memfunc_setup("Class",502,G__dict_284_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::IndexWeight::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_284_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::IndexWeight::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_284_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::IndexWeight::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_284_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::IndexWeight::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_284_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_284_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::IndexWeight::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_284_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::IndexWeight::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_284_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::IndexWeight::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_284_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::IndexWeight::DeclFileLine) ), 0);
   G__memfunc_setup("IndexWeight",1120,G__dict_284_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IndexWeight",1120,G__dict_284_0_14, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 0, 2, 1, 1, 0, 
"u 'TString' - 11 - name_predecessor f - 'Float_t' 0 - weight", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("IndexWeight", 1120, G__dict_284_0_15, (int) ('i'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 0, 1, 1, 1, 0, "u 'ClamLib::IndexWeight' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IndexWeight", 1246, G__dict_284_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_284_0_17, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 1, 1, 1, 1, 0, "u 'ClamLib::IndexWeight' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLCircuitDescription(void) {
   /* ClamLib::CircuitDescription */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription));
   G__memfunc_setup("Class",502,G__dict_285_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::CircuitDescription::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_285_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitDescription::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_285_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::CircuitDescription::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_285_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::CircuitDescription::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_285_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_285_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitDescription::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_285_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::CircuitDescription::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_285_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitDescription::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_285_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::CircuitDescription::DeclFileLine) ), 0);
   G__memfunc_setup("CircuitDescription",1879,G__dict_285_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '0' n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__dict_285_0_14, 104, -1, G__defined_typename("UInt_t"), 0, 1, 1, 1, 0, "u 'ClamLib::CircuitNodeRole' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back_io",1255,G__dict_285_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::InputOutputPair' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_285_0_16, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 1, 1, 1, 1, 9, "h - 'UInt_t' 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddExternal",1100,G__dict_285_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RoleVec",688,G__dict_285_0_18, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR), G__defined_typename("vector<ClamLib::CircuitNodeRole>"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IOVec",438,G__dict_285_0_19, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR), G__defined_typename("vector<ClamLib::InputOutputPair>"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_285_0_20, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IndexExternal",1339,G__dict_285_0_21, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IndexInCircuitByName",1982,G__dict_285_0_22, 104, -1, G__defined_typename("UInt_t"), 0, 1, 1, 1, 8, "C - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FinalizeDescription",1974,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CircuitDescription", 1879, G__dict_285_0_24, (int) ('i'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription), -1, 0, 1, 1, 1, 0, "u 'ClamLib::CircuitDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CircuitDescription", 2005, G__dict_285_0_25, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_285_0_26, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription), -1, 1, 1, 1, 1, 0, "u 'ClamLib::CircuitDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLCircuitNodeRole(void) {
   /* ClamLib::CircuitNodeRole */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole));
   G__memfunc_setup("Class",502,G__dict_286_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::CircuitNodeRole::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_286_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitNodeRole::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_286_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::CircuitNodeRole::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_286_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::CircuitNodeRole::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_286_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_286_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitNodeRole::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_286_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::CircuitNodeRole::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_286_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitNodeRole::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_286_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::CircuitNodeRole::DeclFileLine) ), 0);
   G__memfunc_setup("CircuitNodeRole",1515,G__dict_286_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CircuitNodeRole",1515,G__dict_286_0_14, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 0, 8, 1, 1, 0, 
"u 'string' - 11 - name h - 'UInt_t' 0 - - "
"f - 'Float_t' 0 - - f - 'Float_t' 0 - - "
"f - 'Float_t' 0 - - f - 'Float_t' 0 - - "
"g - - 0 'false' isOutput g - - 0 'true' isPositive", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CircuitNodeRole",1515,G__dict_286_0_15, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 0, 1, 1, 1, 0, "u 'ClamLib::CircuitNodeRole' - 11 - role", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_286_0_16, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Position",853,G__dict_286_0_17, 117, G__get_linked_tagnum(&G__dictLN_DynamicLibcLcLSpatialPosition), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_286_0_18, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 1, 1, 1, 1, 9, "h - 'UInt_t' 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IncomingVec",1106,G__dict_286_0_19, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR), G__defined_typename("vector<ClamLib::IndexWeight>"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__dict_286_0_20, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddIncoming",1085,G__dict_286_0_21, 103, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::IndexWeight' - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isOutput",877,G__dict_286_0_22, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isPositive",1071,G__dict_286_0_23, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CircuitNodeRole", 1641, G__dict_286_0_24, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_286_0_25, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 1, 1, 1, 1, 0, "u 'ClamLib::CircuitNodeRole' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR(void) {
   /* vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR));
   G__memfunc_setup("at",213,G__dict_288_0_1, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__dict_288_0_2, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__dict_288_0_3, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__dict_288_0_4, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__dict_288_0_5, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_288_0_6, 104, -1, G__defined_typename("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__dict_288_0_7, 104, -1, G__defined_typename("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_288_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_288_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type' 0 - sz u 'ClamLib::IndexWeight' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__dict_288_0_10, 104, -1, G__defined_typename("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__dict_288_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_288_0_12, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >",5732,G__dict_288_0_13, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >",5732,G__dict_288_0_14, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type' 0 - n u 'ClamLib::IndexWeight' - 11 'ClamLib::IndexWeight()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >",5732,G__dict_288_0_15, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >",5732,G__dict_288_0_16, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator' - 0 - first u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__dict_288_0_17, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__dict_288_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__dict_288_0_19, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__dict_288_0_20, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLIndexWeight), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__dict_288_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::IndexWeight' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__dict_288_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_288_0_23, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator' - 0 - position u 'ClamLib::IndexWeight' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_288_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator' - 0 - position u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator' - 0 - first "
"u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_288_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator' - 0 - position h - 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::size_type' 0 - n "
"u 'ClamLib::IndexWeight' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__dict_288_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_288_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_288_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator' - 0 - first u 'vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__dict_288_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >", 5858, G__dict_288_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLInputOutputPair(void) {
   /* ClamLib::InputOutputPair */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair));
   G__memfunc_setup("Class",502,G__dict_297_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::InputOutputPair::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_297_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::InputOutputPair::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_297_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::InputOutputPair::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_297_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::InputOutputPair::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_297_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_297_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::InputOutputPair::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_297_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::InputOutputPair::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_297_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::InputOutputPair::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_297_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::InputOutputPair::DeclFileLine) ), 0);
   G__memfunc_setup("InputOutputPair",1581,G__dict_297_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("InputOutputPair", 1581, G__dict_297_0_14, (int) ('i'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair), -1, 0, 1, 1, 1, 0, "u 'ClamLib::InputOutputPair' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~InputOutputPair", 1707, G__dict_297_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_297_0_16, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair), -1, 1, 1, 1, 1, 0, "u 'ClamLib::InputOutputPair' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR(void) {
   /* vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR));
   G__memfunc_setup("at",213,G__dict_299_0_1, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__dict_299_0_2, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__dict_299_0_3, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__dict_299_0_4, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__dict_299_0_5, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_299_0_6, 104, -1, G__defined_typename("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__dict_299_0_7, 104, -1, G__defined_typename("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_299_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_299_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type' 0 - sz u 'ClamLib::CircuitNodeRole' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__dict_299_0_10, 104, -1, G__defined_typename("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__dict_299_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_299_0_12, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >",6522,G__dict_299_0_13, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >",6522,G__dict_299_0_14, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type' 0 - n u 'ClamLib::CircuitNodeRole' - 11 'ClamLib::CircuitNodeRole()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >",6522,G__dict_299_0_15, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >",6522,G__dict_299_0_16, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator' - 0 - first u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__dict_299_0_17, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__dict_299_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__dict_299_0_19, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__dict_299_0_20, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitNodeRole), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__dict_299_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::CircuitNodeRole' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__dict_299_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_299_0_23, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator' - 0 - position u 'ClamLib::CircuitNodeRole' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_299_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator' - 0 - position u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator' - 0 - first "
"u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_299_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator' - 0 - position h - 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::size_type' 0 - n "
"u 'ClamLib::CircuitNodeRole' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__dict_299_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_299_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_299_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator' - 0 - first u 'vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__dict_299_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >", 6648, G__dict_299_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR(void) {
   /* vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR));
   G__memfunc_setup("at",213,G__dict_309_0_1, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__dict_309_0_2, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__dict_309_0_3, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__dict_309_0_4, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__dict_309_0_5, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_309_0_6, 104, -1, G__defined_typename("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__dict_309_0_7, 104, -1, G__defined_typename("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_309_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_309_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type' 0 - sz u 'ClamLib::InputOutputPair' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__dict_309_0_10, 104, -1, G__defined_typename("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__dict_309_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_309_0_12, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >",6654,G__dict_309_0_13, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >",6654,G__dict_309_0_14, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type' 0 - n u 'ClamLib::InputOutputPair' - 11 'ClamLib::InputOutputPair()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >",6654,G__dict_309_0_15, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >",6654,G__dict_309_0_16, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator' - 0 - first u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__dict_309_0_17, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__dict_309_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__dict_309_0_19, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__dict_309_0_20, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLInputOutputPair), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__dict_309_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::InputOutputPair' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__dict_309_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_309_0_23, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator' - 0 - position u 'ClamLib::InputOutputPair' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_309_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator' - 0 - position u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator' - 0 - first "
"u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_309_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator' - 0 - position h - 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::size_type' 0 - n "
"u 'ClamLib::InputOutputPair' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__dict_309_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_309_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_309_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator' - 0 - first u 'vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__dict_309_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >", 6780, G__dict_309_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLCircuitInfo(void) {
   /* ClamLib::CircuitInfo */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo));
   G__memfunc_setup("Class",502,G__dict_318_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::CircuitInfo::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_318_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitInfo::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_318_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::CircuitInfo::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_318_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::CircuitInfo::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_318_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_318_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitInfo::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_318_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::CircuitInfo::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_318_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::CircuitInfo::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_318_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::CircuitInfo::DeclFileLine) ), 0);
   G__memfunc_setup("CircuitInfo",1119,G__dict_318_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ExternalInputId",1536,G__dict_318_0_14, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_318_0_15, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 1, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_318_0_16, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 1, 1, 1, 1, 9, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IdOriginal",994,G__dict_318_0_17, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLId), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reserve",732,G__dict_318_0_18, 121, -1, -1, 0, 3, 1, 1, 0, 
"C - - 10 - Name i - - 0 - - "
"u 'ClamLib::Id' - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NumberOfNodes",1303,G__dict_318_0_19, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetExternal",1135,G__dict_318_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::Id' - 0 - -", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CircuitInfo", 1119, G__dict_318_0_21, (int) ('i'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo), -1, 0, 1, 1, 1, 0, "u 'ClamLib::CircuitInfo' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CircuitInfo", 1245, G__dict_318_0_22, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_318_0_23, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo), -1, 1, 1, 1, 1, 0, "u 'ClamLib::CircuitInfo' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLSimulationInfoBlock(void) {
   /* ClamLib::SimulationInfoBlock */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock));
   G__memfunc_setup("Class",502,G__dict_330_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::SimulationInfoBlock::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_330_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::SimulationInfoBlock::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_330_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::SimulationInfoBlock::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_330_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::SimulationInfoBlock::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_330_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_330_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::SimulationInfoBlock::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_330_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::SimulationInfoBlock::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_330_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::SimulationInfoBlock::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_330_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::SimulationInfoBlock::DeclFileLine) ), 0);
   G__memfunc_setup("SimulationInfoBlock",1948,G__dict_330_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SimulationInfoBlock",1948,G__dict_330_0_14, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 0, 1, 1, 1, 0, "u 'ClamLib::SimulationInfoBlock' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SimulationInfoBlock",1948,G__dict_330_0_15, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 0, 1, 1, 1, 0, "u 'ClamLib::DynamicSubNetwork' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SimulationInfoBlock",1948,G__dict_330_0_16, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 0, 4, 1, 1, 0, 
"u 'TString' - 11 - - u 'ClamLib::RootLayeredNetDescription' - 11 - - "
"u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >' 'vector<ClamLib::CircuitInfo>' 11 - - u 'ClamLib::CircuitDescription' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__dict_330_0_17, 117, G__get_linked_tagnum(&G__dictLN_TString), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("InfoVector",1023,G__dict_330_0_18, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR), G__defined_typename("vector<ClamLib::CircuitInfo>"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DescriptionVector",1783,G__dict_330_0_19, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLRootLayeredNetDescription), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DescriptionCircuit",1879,G__dict_330_0_20, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitDescription), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SimulationInfoBlock", 2074, G__dict_330_0_21, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_330_0_22, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 1, 1, 1, 1, 0, "u 'ClamLib::SimulationInfoBlock' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR(void) {
   /* vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR));
   G__memfunc_setup("at",213,G__dict_332_0_1, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__dict_332_0_2, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__dict_332_0_3, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__dict_332_0_4, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__dict_332_0_5, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_332_0_6, 104, -1, G__defined_typename("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__dict_332_0_7, 104, -1, G__defined_typename("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_332_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_332_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type' 0 - sz u 'ClamLib::CircuitInfo' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__dict_332_0_10, 104, -1, G__defined_typename("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__dict_332_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_332_0_12, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >",5730,G__dict_332_0_13, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >",5730,G__dict_332_0_14, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type' 0 - n u 'ClamLib::CircuitInfo' - 11 'ClamLib::CircuitInfo()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >",5730,G__dict_332_0_15, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >",5730,G__dict_332_0_16, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator' - 0 - first u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__dict_332_0_17, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__dict_332_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__dict_332_0_19, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__dict_332_0_20, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLCircuitInfo), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__dict_332_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::CircuitInfo' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__dict_332_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_332_0_23, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator' - 0 - position u 'ClamLib::CircuitInfo' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_332_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator' - 0 - position u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator' - 0 - first "
"u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_332_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator' - 0 - position h - 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::size_type' 0 - n "
"u 'ClamLib::CircuitInfo' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__dict_332_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_332_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_332_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator' - 0 - first u 'vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__dict_332_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >", 5856, G__dict_332_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncClamLibcLcLSimulationInfoBlockVector(void) {
   /* ClamLib::SimulationInfoBlockVector */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector));
   G__memfunc_setup("Class",502,G__dict_341_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&ClamLib::SimulationInfoBlockVector::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_341_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::SimulationInfoBlockVector::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_341_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&ClamLib::SimulationInfoBlockVector::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_341_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&ClamLib::SimulationInfoBlockVector::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_341_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_341_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::SimulationInfoBlockVector::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_341_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::SimulationInfoBlockVector::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_341_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&ClamLib::SimulationInfoBlockVector::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_341_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ClamLib::SimulationInfoBlockVector::DeclFileLine) ), 0);
   G__memfunc_setup("SimulationInfoBlockVector",2575,G__dict_341_0_13, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SimulationInfoBlockVector",2575,G__dict_341_0_14, 105, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >' 'vector<ClamLib::SimulationInfoBlock>' 11 - -", "namespace is necessary, due to a bug in CINT (root 5.17)", (void*) NULL, 0);
   G__memfunc_setup("NumberOfBlocks",1404,G__dict_341_0_15, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BlockVector",1118,G__dict_341_0_16, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR), G__defined_typename("vector<ClamLib::SimulationInfoBlock>"), 1, 0, 1, 1, 9, "", "namespace is necessary, due to a bug in CINT (root 5.17)", (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SimulationInfoBlockVector", 2575, G__dict_341_0_17, (int) ('i'), 
G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector), -1, 0, 1, 1, 1, 0, "u 'ClamLib::SimulationInfoBlockVector' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SimulationInfoBlockVector", 2701, G__dict_341_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_341_0_19, (int) ('u'), G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector), -1, 1, 1, 1, 1, 0, "u 'ClamLib::SimulationInfoBlockVector' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR(void) {
   /* vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR));
   G__memfunc_setup("at",213,G__dict_343_0_1, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__dict_343_0_2, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__dict_343_0_3, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__dict_343_0_4, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__dict_343_0_5, 117, G__get_linked_tagnum(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiteratorgR), G__defined_typename("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__dict_343_0_6, 104, -1, G__defined_typename("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__dict_343_0_7, 104, -1, G__defined_typename("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_343_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__dict_343_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type' 0 - sz u 'ClamLib::SimulationInfoBlock' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__dict_343_0_10, 104, -1, G__defined_typename("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__dict_343_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__dict_343_0_12, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 1, 1, 1, 1, 0, "h - 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >",7388,G__dict_343_0_13, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >",7388,G__dict_343_0_14, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type' 0 - n u 'ClamLib::SimulationInfoBlock' - 11 'ClamLib::SimulationInfoBlock()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >",7388,G__dict_343_0_15, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >",7388,G__dict_343_0_16, 105, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator' - 0 - first u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__dict_343_0_17, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__dict_343_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__dict_343_0_19, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__dict_343_0_20, 117, G__get_linked_tagnum(&G__dictLN_ClamLibcLcLSimulationInfoBlock), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__dict_343_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ClamLib::SimulationInfoBlock' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__dict_343_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_343_0_23, 117, G__get_linked_tagnum(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator' - 0 - position u 'ClamLib::SimulationInfoBlock' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_343_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator' - 0 - position u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator' - 0 - first "
"u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__dict_343_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator' - 0 - position h - 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::size_type' 0 - n "
"u 'ClamLib::SimulationInfoBlock' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__dict_343_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_343_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__dict_343_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator' - 0 - first u 'vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__dict_343_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >", 7514, G__dict_343_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncWeightedLinklEdoublegR(void) {
   /* WeightedLink<double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR));
   G__memfunc_setup("Class",502,G__dict_352_0_1, 85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&WeightedLink<double>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__dict_352_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&WeightedLink<double>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__dict_352_0_3, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&WeightedLink<double>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__dict_352_0_4, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&WeightedLink<double>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__dictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TMemberInspector' - 1 - insp", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__dict_352_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__dict_352_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&WeightedLink<double>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__dict_352_0_10, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&WeightedLink<double>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__dict_352_0_11, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&WeightedLink<double>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__dict_352_0_12, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&WeightedLink<double>::DeclFileLine) ), 0);
   G__memfunc_setup("WeightedLink<double>",1972,G__dict_352_0_13, 105, G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WeightedLink<double>",1972,G__dict_352_0_14, 105, G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR), -1, 0, 3, 1, 1, 0, 
"u 'ClamLib::Id' - 0 - id_from u 'ClamLib::Id' - 0 - id_to "
"d - - 0 - weight", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("WeightedLink<double>", 1972, G__dict_352_0_15, (int) ('i'), G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR), -1, 0, 1, 1, 1, 0, "u 'WeightedLink<double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~WeightedLink<double>", 2098, G__dict_352_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__dict_352_0_17, (int) ('u'), G__get_linked_tagnum(&G__dictLN_WeightedLinklEdoublegR), -1, 1, 1, 1, 1, 0, "u 'WeightedLink<double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncdict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globaldict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcdict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__dictLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__dictLN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__dictLN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__dictLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__dictLN_TNamed = { "TNamed" , 99 , -1 };
G__linked_taginfo G__dictLN_TString = { "TString" , 99 , -1 };
G__linked_taginfo G__dictLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR = { "_Ranit<ROOT::TSchemaHelper,long,ROOT::TSchemaHelper*,ROOT::TSchemaHelper&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR = { "iterator<random_access_iterator_tag,ROOT::TSchemaHelper,long,ROOT::TSchemaHelper*,ROOT::TSchemaHelper&>" , 115 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlETVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR = { "_Ranit<TVirtualArray*,long,TVirtualArray**,TVirtualArray*&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR = { "iterator<random_access_iterator_tag,TVirtualArray*,long,TVirtualArray**,TVirtualArray*&>" , 115 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLib = { "ClamLib" , 110 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLRootLayerDescription = { "ClamLib::RootLayerDescription" , 115 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLRootLayeredNetDescription = { "ClamLib::RootLayeredNetDescription" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR = { "vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iterator = { "vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR = { "_Ranit<ClamLib::RootLayerDescription,long,ClamLib::RootLayerDescription*,ClamLib::RootLayerDescription&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR = { "iterator<random_access_iterator_tag,ClamLib::RootLayerDescription,long,ClamLib::RootLayerDescription*,ClamLib::RootLayerDescription&>" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiterator = { "vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLId = { "ClamLib::Id" , 115 , -1 };
G__linked_taginfo G__dictLN_DynamicLib = { "DynamicLib" , 110 , -1 };
G__linked_taginfo G__dictLN_DynamicLibcLcLSpatialPosition = { "DynamicLib::SpatialPosition" , 115 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLIndexWeight = { "ClamLib::IndexWeight" , 115 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLCircuitDescription = { "ClamLib::CircuitDescription" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLCircuitNodeRole = { "ClamLib::CircuitNodeRole" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR = { "vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iterator = { "vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR = { "_Ranit<ClamLib::IndexWeight,long,ClamLib::IndexWeight*,ClamLib::IndexWeight&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR = { "iterator<random_access_iterator_tag,ClamLib::IndexWeight,long,ClamLib::IndexWeight*,ClamLib::IndexWeight&>" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiterator = { "vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLInputOutputPair = { "ClamLib::InputOutputPair" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR = { "vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iterator = { "vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR = { "_Ranit<ClamLib::CircuitNodeRole,long,ClamLib::CircuitNodeRole*,ClamLib::CircuitNodeRole&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR = { "iterator<random_access_iterator_tag,ClamLib::CircuitNodeRole,long,ClamLib::CircuitNodeRole*,ClamLib::CircuitNodeRole&>" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiterator = { "vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR = { "vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iterator = { "vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR = { "_Ranit<ClamLib::InputOutputPair,long,ClamLib::InputOutputPair*,ClamLib::InputOutputPair&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR = { "iterator<random_access_iterator_tag,ClamLib::InputOutputPair,long,ClamLib::InputOutputPair*,ClamLib::InputOutputPair&>" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiterator = { "vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLCircuitInfo = { "ClamLib::CircuitInfo" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR = { "vector<ClamLib::Id,allocator<ClamLib::Id> >" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR = { "_Ranit<ClamLib::Id,long,ClamLib::Id*,ClamLib::Id&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR = { "iterator<random_access_iterator_tag,ClamLib::Id,long,ClamLib::Id*,ClamLib::Id&>" , 115 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ClamLib::Id,allocator<ClamLib::Id> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ClamLib::Id,allocator<ClamLib::Id> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLDynamicSubNetwork = { "ClamLib::DynamicSubNetwork" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLSimulationInfoBlock = { "ClamLib::SimulationInfoBlock" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR = { "vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iterator = { "vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR = { "_Ranit<ClamLib::CircuitInfo,long,ClamLib::CircuitInfo*,ClamLib::CircuitInfo&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR = { "iterator<random_access_iterator_tag,ClamLib::CircuitInfo,long,ClamLib::CircuitInfo*,ClamLib::CircuitInfo&>" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiterator = { "vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_ClamLibcLcLSimulationInfoBlockVector = { "ClamLib::SimulationInfoBlockVector" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR = { "vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >" , 99 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iterator = { "vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator" , 99 , -1 };
G__linked_taginfo G__dictLN__RanitlEClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR = { "_Ranit<ClamLib::SimulationInfoBlock,long,ClamLib::SimulationInfoBlock*,ClamLib::SimulationInfoBlock&>" , 115 , -1 };
G__linked_taginfo G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR = { "iterator<random_access_iterator_tag,ClamLib::SimulationInfoBlock,long,ClamLib::SimulationInfoBlock*,ClamLib::SimulationInfoBlock&>" , 115 , -1 };
G__linked_taginfo G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiterator = { "vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__dictLN_WeightedLinklEdoublegR = { "WeightedLink<double>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtabledict() {
  G__dictLN_TClass.tagnum = -1 ;
  G__dictLN_TBuffer.tagnum = -1 ;
  G__dictLN_TMemberInspector.tagnum = -1 ;
  G__dictLN_TObject.tagnum = -1 ;
  G__dictLN_TNamed.tagnum = -1 ;
  G__dictLN_TString.tagnum = -1 ;
  G__dictLN_string.tagnum = -1 ;
  G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__dictLN__RanitlEROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__dictLN__RanitlETVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_ClamLib.tagnum = -1 ;
  G__dictLN_ClamLibcLcLRootLayerDescription.tagnum = -1 ;
  G__dictLN_ClamLibcLcLRootLayeredNetDescription.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iterator.tagnum = -1 ;
  G__dictLN__RanitlEClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiterator.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_ClamLibcLcLId.tagnum = -1 ;
  G__dictLN_DynamicLib.tagnum = -1 ;
  G__dictLN_DynamicLibcLcLSpatialPosition.tagnum = -1 ;
  G__dictLN_ClamLibcLcLIndexWeight.tagnum = -1 ;
  G__dictLN_ClamLibcLcLCircuitDescription.tagnum = -1 ;
  G__dictLN_ClamLibcLcLCircuitNodeRole.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iterator.tagnum = -1 ;
  G__dictLN__RanitlEClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiterator.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_ClamLibcLcLInputOutputPair.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iterator.tagnum = -1 ;
  G__dictLN__RanitlEClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiterator.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iterator.tagnum = -1 ;
  G__dictLN__RanitlEClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiterator.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_ClamLibcLcLCircuitInfo.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR.tagnum = -1 ;
  G__dictLN__RanitlEClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_ClamLibcLcLDynamicSubNetwork.tagnum = -1 ;
  G__dictLN_ClamLibcLcLSimulationInfoBlock.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iterator.tagnum = -1 ;
  G__dictLN__RanitlEClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiterator.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_ClamLibcLcLSimulationInfoBlockVector.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iterator.tagnum = -1 ;
  G__dictLN__RanitlEClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR.tagnum = -1 ;
  G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR.tagnum = -1 ;
  G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiterator.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__dictLN_WeightedLinklEdoublegR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtabledict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__dictLN_TClass);
   G__get_linked_tagnum_fwd(&G__dictLN_TBuffer);
   G__get_linked_tagnum_fwd(&G__dictLN_TMemberInspector);
   G__get_linked_tagnum_fwd(&G__dictLN_TObject);
   G__get_linked_tagnum_fwd(&G__dictLN_TNamed);
   G__get_linked_tagnum_fwd(&G__dictLN_TString);
   G__get_linked_tagnum_fwd(&G__dictLN_string);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlETVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_ClamLib);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLRootLayerDescription),sizeof(ClamLib::RootLayerDescription),-1,323840,(char*)NULL,G__setup_memvarClamLibcLcLRootLayerDescription,G__setup_memfuncClamLibcLcLRootLayerDescription);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLRootLayeredNetDescription),sizeof(ClamLib::RootLayeredNetDescription),-1,323840,(char*)NULL,G__setup_memvarClamLibcLcLRootLayeredNetDescription,G__setup_memfuncClamLibcLcLRootLayeredNetDescription);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR),sizeof(vector<ClamLib::RootLayerDescription,allocator<ClamLib::RootLayerDescription> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR,G__setup_memfuncvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iterator);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLRootLayerDescriptioncOlongcOClamLibcLcLRootLayerDescriptionmUcOClamLibcLcLRootLayerDescriptionaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLRootLayerDescriptioncOallocatorlEClamLibcLcLRootLayerDescriptiongRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLId),sizeof(ClamLib::Id),-1,325888,(char*)NULL,G__setup_memvarClamLibcLcLId,G__setup_memfuncClamLibcLcLId);
   G__get_linked_tagnum_fwd(&G__dictLN_DynamicLib);
   G__get_linked_tagnum_fwd(&G__dictLN_DynamicLibcLcLSpatialPosition);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLIndexWeight),sizeof(ClamLib::IndexWeight),-1,323840,(char*)NULL,G__setup_memvarClamLibcLcLIndexWeight,G__setup_memfuncClamLibcLcLIndexWeight);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLCircuitDescription),sizeof(ClamLib::CircuitDescription),-1,323840,(char*)NULL,G__setup_memvarClamLibcLcLCircuitDescription,G__setup_memfuncClamLibcLcLCircuitDescription);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLCircuitNodeRole),sizeof(ClamLib::CircuitNodeRole),-1,324352,(char*)NULL,G__setup_memvarClamLibcLcLCircuitNodeRole,G__setup_memfuncClamLibcLcLCircuitNodeRole);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR),sizeof(vector<ClamLib::IndexWeight,allocator<ClamLib::IndexWeight> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR,G__setup_memfuncvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iterator);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIndexWeightcOlongcOClamLibcLcLIndexWeightmUcOClamLibcLcLIndexWeightaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIndexWeightcOallocatorlEClamLibcLcLIndexWeightgRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLInputOutputPair),sizeof(ClamLib::InputOutputPair),-1,291072,(char*)NULL,G__setup_memvarClamLibcLcLInputOutputPair,G__setup_memfuncClamLibcLcLInputOutputPair);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR),sizeof(vector<ClamLib::CircuitNodeRole,allocator<ClamLib::CircuitNodeRole> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR,G__setup_memfuncvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iterator);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitNodeRolecOlongcOClamLibcLcLCircuitNodeRolemUcOClamLibcLcLCircuitNodeRoleaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitNodeRolecOallocatorlEClamLibcLcLCircuitNodeRolegRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR),sizeof(vector<ClamLib::InputOutputPair,allocator<ClamLib::InputOutputPair> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR,G__setup_memfuncvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iterator);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLInputOutputPaircOlongcOClamLibcLcLInputOutputPairmUcOClamLibcLcLInputOutputPairaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLInputOutputPaircOallocatorlEClamLibcLcLInputOutputPairgRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLCircuitInfo),sizeof(ClamLib::CircuitInfo),-1,323840,(char*)NULL,G__setup_memvarClamLibcLcLCircuitInfo,G__setup_memfuncClamLibcLcLCircuitInfo);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLIdcOlongcOClamLibcLcLIdmUcOClamLibcLcLIdaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLIdcOallocatorlEClamLibcLcLIdgRsPgRcLcLconst_iteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLDynamicSubNetwork);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLSimulationInfoBlock),sizeof(ClamLib::SimulationInfoBlock),-1,324352,(char*)NULL,G__setup_memvarClamLibcLcLSimulationInfoBlock,G__setup_memfuncClamLibcLcLSimulationInfoBlock);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR),sizeof(vector<ClamLib::CircuitInfo,allocator<ClamLib::CircuitInfo> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR,G__setup_memfuncvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iterator);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLCircuitInfocOlongcOClamLibcLcLCircuitInfomUcOClamLibcLcLCircuitInfoaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLCircuitInfocOallocatorlEClamLibcLcLCircuitInfogRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_ClamLibcLcLSimulationInfoBlockVector),sizeof(ClamLib::SimulationInfoBlockVector),-1,323840,(char*)NULL,G__setup_memvarClamLibcLcLSimulationInfoBlockVector,G__setup_memfuncClamLibcLcLSimulationInfoBlockVector);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR),sizeof(vector<ClamLib::SimulationInfoBlock,allocator<ClamLib::SimulationInfoBlock> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR,G__setup_memfuncvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iterator);
   G__get_linked_tagnum_fwd(&G__dictLN__RanitlEClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_iteratorlErandom_access_iterator_tagcOClamLibcLcLSimulationInfoBlockcOlongcOClamLibcLcLSimulationInfoBlockmUcOClamLibcLcLSimulationInfoBlockaNgR);
   G__get_linked_tagnum_fwd(&G__dictLN_vectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__dictLN_reverse_iteratorlEvectorlEClamLibcLcLSimulationInfoBlockcOallocatorlEClamLibcLcLSimulationInfoBlockgRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__dictLN_WeightedLinklEdoublegR),sizeof(WeightedLink<double>),-1,323840,(char*)NULL,G__setup_memvarWeightedLinklEdoublegR,G__setup_memfuncWeightedLinklEdoublegR);
}
extern "C" void G__cpp_setupdict(void) {
  G__check_setup_version(30051515,"G__cpp_setupdict()");
  G__set_cpp_environmentdict();
  G__cpp_setup_tagtabledict();

  G__cpp_setup_inheritancedict();

  G__cpp_setup_typetabledict();

  G__cpp_setup_memvardict();

  G__cpp_setup_memfuncdict();
  G__cpp_setup_globaldict();
  G__cpp_setup_funcdict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncdict();
  return;
}
class G__cpp_setup_initdict {
  public:
    G__cpp_setup_initdict() { G__add_setup_func("dict",(G__incsetup)(&G__cpp_setupdict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initdict() { G__remove_setup_func("dict"); }
};
G__cpp_setup_initdict G__cpp_setup_initializerdict;

