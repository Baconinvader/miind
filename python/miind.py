#!/usr/bin/env python3
import os
import re
import argparse
import numpy as np
import xml.etree.ElementTree as ET
import directories3 as directories
from collections import Counter

# These algorithms can feature in a MeshAlgorithmGroup simulation, and no others
MESH_ALGORITHM_GROUP_LIST = ['GridAlgorithmGroup', 'MeshAlgorithmGroup', 'DelayAlgorithm', 'RateFunctor' ]

def parse_rate_functors(algorithms):
     s=''
     for algorithm in algorithms:
          if algorithm.attrib['type'] == 'RateFunctor':
             expression = algorithm.find('expression')
             name=re.sub(r'\s+', '_', algorithm.attrib['name']) # a user may use white space, we need to replace it
             s += 'MPILib::Rate ' + name + '( MPILib::Time t ){\n'
             s += '\treturn ' + expression.text + ';\n'
             s += '}\n\n'
     return s


def generate_variable_declarations(variables):
     s = ''
     for variable in variables:
          s += '\tconst float ' + variable.attrib['Name'] + ' = ' + variable.text + ';\n'
     s += '\n'
     return s


def generate_preamble(fn, variables, nodes, algorithms, connections, cuda):
    '''Generates the function declarations, required for RateFunctors etc in the C++ file. fn is the file name where the C++
    is to be written. variable, nodes and algorithms are XML elements.'''

    # the rate functor functions need to be declared before the main program
    function_declarations = parse_rate_functors(algorithms)
    variable_declarations = generate_variable_declarations(variables)

    if cuda == True:
         template_argument = 'fptype'
    else:
         template_argument = 'MPILib::Rate'

    with open(fn,'w') as f:
        f.write('//Machine-generated by miind.py. Edit at your own risk.\n\n')
        f.write('#include <boost/timer/timer.hpp>\n')
        f.write('#include <GeomLib.hpp>\n')
        f.write('#include <TwoDLib.hpp>\n')
        if cuda == True: f.write('#include <CudaTwoDLib.hpp>\n')
        f.write('#include <MPILib/include/RateAlgorithmCode.hpp>\n')
        f.write('#include <MPILib/include/SimulationRunParameter.hpp>\n')
        f.write('#include <MPILib/include/DelayAlgorithmCode.hpp>\n')
        f.write('#include <MPILib/include/RateFunctorCode.hpp>\n\n')
        f.write('#include <MiindLib/VectorizedNetwork.hpp>\n\n')
        if cuda == True: f.write('typedef CudaTwoDLib::fptype fptype;\n')
        f.write(function_declarations)
        f.write('\n')
        f.write('\nint main(int argc, char *argv[]){\n')
        f.write(variable_declarations)
        f.write('\n')
        f.write('\tMiindLib::VectorizedNetwork network(0.001);\n')
        f.write('\tpugi::xml_document doc;\n')
        f.write('\n')

def generate_closing(fn):
    '''Generates the closing statements in the C++ file.'''
    with open(fn,'a') as f:
        f.write('\n')
        f.write('\treturn 0;\n')
        f.write('}\n')

def process_tree(root):

    variables=root.findall(".//Variable")
    nodes=root.findall('.//Node')
    algorithms=root.findall('.//Algorithm')
    connections=root.findall('.//Connection')
    parameters=root.findall('.//SimulationRunParameter')
    io=root.findall('.//SimulationIO')
    return variables, nodes, algorithms, connections, parameters, io

def parse(fn):
    '''Takes a filename. Puts the file with filename fn through the XML parser. Returns nothing.'''
    try:
        tree = ET.parse(fn)
        root = tree.getroot()

    except FileNotFoundError:
        print('No file ' + fn)
    return root

def generate_simulation_parameter(fn, parameters):
     '''Write the simulation parameter into the simulation file specified by file name fn.'''
     t_start_els = parameters[0].findall('t_begin')
     t_start = t_start_els[0].text

     t_end_els = parameters[0].findall('t_end')
     t_end = t_end_els[0].text

     t_report_els = parameters[0].findall('t_report')
     t_report = t_report_els[0].text

     t_network_els = parameters[0].findall('t_step')
     t_network = t_network_els[0].text

     with open(fn,'a') as f:
          f.write('\n')
          f.write('\tMPILib::Time t_begin = ' + t_start + ';\n')
          f.write('\tMPILib::Time t_end = ' + t_end + ';\n')
          f.write('\tMPILib::Time t_report = ' + t_report + ';\n')
          f.write('\tMPILib::Time t_step = ' + t_network + ';\n\n')
          f.write('\tMPILib::Number n_iter = static_cast<MPILib::Number>(ceil((t_end - t_begin)/t_step));\n')
          f.write('\tMPILib::Number n_report = static_cast<MPILib::Number>(ceil((t_report - t_begin)/t_step));\n')


def generate_model_files(nodes,algorithms):
     modelfiles=[]
     for node in nodes:
          algname = node.attrib['algorithm']
          for alg in algorithms:
               if alg.attrib['name'] == algname: # here we assume the name is unique
                    algorithm = alg

          if algorithm.attrib['type'] == 'MeshAlgorithmGroup':
               modelfiles.append(algorithm.attrib['modelfile'])
               ts = algorithm.findall('TimeStep')
               timestep = float(ts[0].text)

     if len(modelfiles) == 0:
        return modelfiles, -1.0

     return modelfiles, timestep

def generate_mesh_algorithm_group(fn,nodes,algorithms,cuda):
     '''Colate al MeshAlgorithmGroup instances and generate the C++ code to instantiate the group'''

     modelfiles, timestep = generate_model_files(nodes,algorithms)

     if len(modelfiles) == 0:
         return

     with open(fn,'a') as f:
          for i,model in enumerate(modelfiles):
               # according to pugixml doc, load_file destroys the old tree, soo this should be save
               f.write('\tpugi::xml_parse_result result' + str(i) + ' = doc.load_file(\"' + model +'\");\n')
               f.write('\tpugi::xml_node  root' + str(i) + ' = doc.first_child();\n\n')
               f.write('\tTwoDLib::Mesh mesh' + str(i) +' = TwoDLib::RetrieveMeshFromXML(root' + str(i) + ');\n')
               f.write('\tstd::vector<TwoDLib::Redistribution> vec_rev' + str(i) + ' = TwoDLib::RetrieveMappingFromXML("Reversal",root' + str(i) + ');\n')
               f.write('\tstd::vector<TwoDLib::Redistribution> vec_res' + str(i) + ' = TwoDLib::RetrieveMappingFromXML("Reset",root' + str(i) + ');\n\n')
               f.write('\tnetwork.addMeshNode(mesh'+ str(i) +', vec_rev'+ str(i) +', vec_res'+ str(i) +');\n')


def generate_grid_model_files(nodes,algorithms):
     modelfiles=[]
     transforms=[]
     startvs=[]
     startws=[]
     for node in nodes:
          algname = node.attrib['algorithm']
          for alg in algorithms:
               if alg.attrib['name'] == algname: # here we assume the name is unique
                    algorithm = alg

          if algorithm.attrib['type'] == 'GridAlgorithmGroup':
               modelfiles.append(algorithm.attrib['modelfile'])
               transforms.append(algorithm.attrib['transformfile'])
               startvs.append(algorithm.attrib['start_v'])
               startws.append(algorithm.attrib['start_w'])
               ts = algorithm.findall('TimeStep')
               timestep = float(ts[0].text)

     return modelfiles, transforms, startvs, startws, timestep

def generate_grid_algorithm_group(fn,nodes,algorithms,cuda):
     '''Colate al MeshAlgorithmGroup instances and generate the C++ code to instantiate the group'''

     modelfiles, transforms, startvs, startws, timestep = generate_grid_model_files(nodes,algorithms)

     with open(fn,'a') as f:
          for i,model in enumerate(modelfiles):
               # according to pugixml doc, load_file destroys the old tree, soo this should be save
               f.write('\tpugi::xml_parse_result result' + str(i) + ' = doc.load_file(\"' + model +'\");\n')
               f.write('\tpugi::xml_node  root' + str(i) + ' = doc.first_child();\n\n')
               f.write('\tTwoDLib::Mesh mesh' + str(i) +' = TwoDLib::RetrieveMeshFromXML(root' + str(i) + ');\n')
               f.write('\tstd::vector<TwoDLib::Redistribution> vec_rev' + str(i) + ' = TwoDLib::RetrieveMappingFromXML("Reversal",root' + str(i) + ');\n')
               f.write('\tstd::vector<TwoDLib::Redistribution> vec_res' + str(i) + ' = TwoDLib::RetrieveMappingFromXML("Reset",root' + str(i) + ');\n\n')
               f.write('\tTwoDLib::TransitionMatrix transform' + str(i) + '(\"' + transforms[i] + '\");\n')
               f.write('\tvec_transforms.push_back(transform'+str(i)+');\n\n')
               f.write('\tnetwork.addGridNode(mesh'+ str(i) +', transform'+ str(i) +', ' + str(startvs[i]) + ', ' + str(startws[i]) +', vec_rev'+ str(i) +', vec_res'+ str(i) +');\n')

def node_name_to_node_id(nodes):
     '''Create a map from name to NodeId from node elements. Return this map.'''
     d ={}
     for i,node in enumerate(nodes):
          d[node.attrib['name']] = i
     return d

def extract_efficacy(fn):
     '''Extract efficacy from a matrix file. Takes a filename, returns efficacy as a single float. In the
     file efficacies are represented by two numbers. We will assume for now that one of them in zero. We will
     return the non-zero number as efficacy.'''

     with open(fn) as f:
          line=f.readline()
          nrs = [ float(x) for x in line.split()]
          if nrs[0] == 0.:
               return nrs[1]
          else:
               if nrs[1] != 0:
                    raise ValueError('Expected at least one non-zero value')
               return nrs[0]



def node_id_to_mag_id(nodes, algorithms):
     '''MagId is determined by the node order. Every time a MeshAlgorithmGroup is encoutered when traversing nodes in their  order in the XML file, the MagId
     is increased.'''
     map = []
     nodecounter = 0
     magcounter = 0
     for node in nodes:
          algname = node.attrib['algorithm']
          for algorithm in algorithms:
               if algorithm.attrib['name'] == algname:
                    if algorithm.attrib['type'] == 'MeshAlgorithmGroup':
                         map.append([[nodecounter],[magcounter]])
                         magcounter += 1
          nodecounter += 1
     return map

def node_id_to_gag_id(nodes, algorithms):
     '''MagId is determined by the node order. Every time a MeshAlgorithmGroup is encoutered when traversing nodes in their  order in the XML file, the MagId
     is increased.'''
     map = []
     nodecounter = 0
     gagcounter = 0
     for node in nodes:
          algname = node.attrib['algorithm']
          for algorithm in algorithms:
               if algorithm.attrib['name'] == algname:
                    if algorithm.attrib['type'] == 'GridAlgorithmGroup':
                         map.append([[nodecounter],[gagcounter]])
                         gagcounter += 1
          nodecounter += 1
     return map

def node_name_to_mag_id(nodes,algorithms):
     '''Map a node name to the correct MagId, if it exists.'''
     map = {}
     magcounter = 0
     for node in nodes:
          algname = node.attrib['algorithm']
          for algorithm in algorithms:
               if algorithm.attrib['name'] == algname:
                    if algorithm.attrib['type'] == 'MeshAlgorithmGroup':
                         map[node.attrib['name']]  = magcounter
                         magcounter += 1
     return map

def node_name_to_gag_id(nodes,algorithms):
     '''Map a node name to the correct MagId, if it exists.'''
     map = {}
     gagcounter = 0
     for node in nodes:
          algname = node.attrib['algorithm']
          for algorithm in algorithms:
               if algorithm.attrib['name'] == algname:
                    if algorithm.attrib['type'] == 'GridAlgorithmGroup':
                         map[node.attrib['name']]  = gagcounter
                         gagcounter += 1
     return map


def construct_CSR_map(nodes,algorithms,connections):
     '''Creates a list that corresponds one-to-one with the connection structure. Returns a tuple: [0] node name of receiving node,[1] matrix file name for this connection  '''
     csrlist=[]
     combi = []
     for connection in connections:
          for node in nodes:
               if connection.attrib['Out'] == node.attrib['name']:
                    # we have the right node, now see if it's a MeshAlgorithmGroup
                    nodealgorithm=node.attrib['algorithm']
                    for algorithm in algorithms:
                         if nodealgorithm == algorithm.attrib['name']:
                              if algorithm.attrib['type'] == 'MeshAlgorithmGroup':


                                   mfs=algorithm.findall('MatrixFile')
                                   mfn= [ mf.text for mf in mfs]
                                   efficacy=float(connection.text.split()[1])
                                   effs= [extract_efficacy(fn) for fn in mfn]

                                   candidates=[]
                                   for i, eff in enumerate(effs):
                                        if np.isclose(eff,efficacy):
                                             candidates.append(i)
                                   if len(candidates) == 0: raise ValueError('No efficacy found that corresponds to the connection efficacy ' + str(efficacy))
                                   if len(candidates) > 1: raise ValueError('Same efficacy found twice')

                                   count = Counter(combi)
                                   combi.append((connection.attrib['Out'],connection.attrib['In']))
                                   nr_connection = count[(connection.attrib['Out'],connection.attrib['In'])]
                                   csrlist.append([node.attrib['name'],mfn[candidates[0]], effs[candidates[0]],connection.attrib['In'],nr_connection])

     return csrlist

def construct_efficacy_map(nodes,algorithms,connections):
     '''Creates a list that corresponds one-to-one with the connection structure. Returns a tuple: [0] node name of receiving node,[1] matrix file name for this connection  '''
     csrlist=[]
     combi = []
     for connection in connections:
          for node in nodes:
               if connection.attrib['Out'] == node.attrib['name']:
                    # we have the right node, now see if it's a MeshAlgorithmGroup
                    nodealgorithm=node.attrib['algorithm']
                    for algorithm in algorithms:
                         if nodealgorithm == algorithm.attrib['name']:
                              if algorithm.attrib['type'] == 'GridAlgorithmGroup':
                                   efficacy=float(connection.text.split()[1])

                                   csrlist.append([node.attrib['name'],efficacy,connection.attrib['In'],int(connection.text.split()[0]),int(connection.text.split()[2])])

     return csrlist

def generate_connectivity(fn, nodes, algorithms, connections,cuda):
     '''Write out the CSR matrix lists and vectors into the C++ file.'''
     map = construct_CSR_map(nodes,algorithms,connections)
     nodemap=node_name_to_node_id(nodes)
     magmap=node_name_to_mag_id(nodes,algorithms)

     if len(magmap) == 0:
         return

     with open(fn,'a') as f:
          for el in map:
               f.write('\tTwoDLib::TransitionMatrix mat_' + str(nodemap[el[0]]) + '_' + str(nodemap[el[3]]) + '_' + str(el[4]) + '(\"' + el[1] + '\");\n')
          f.write('\tconst std::vector<TwoDLib::CSRMatrix> vecmat {\\\n')

          if cuda == True:
               template_argument = 'fptype'
               group = ', group_ode,'
          else:
               group = ', group,'
               template_argument = 'MPILib::Rate'

          for el in map[:-1]:
               f.write('\t\tTwoDLib::CSRMatrix(mat_' + str(nodemap[el[0]]) + '_' + str(nodemap[el[3]])+ '_' + str(el[4]) + group +  str(magmap[el[0]]) + '), \\\n')
          el = map[-1]
          f.write('\t\tTwoDLib::CSRMatrix(mat_' + str(nodemap[el[0]]) + '_' + str(nodemap[el[3]])+ '_' + str(el[4]) + group +  str(magmap[el[0]]) + ') \\\n')
          f.write('\t};\n')
          f.write('\tstd::vector<' + template_argument + '> vec_magin_rates(vecmat.size(),0.);\n\n')
          f.write('\n')
          if cuda:
               f.write('\tCudaTwoDLib::CSRAdapter csr_adapter(group,vecmat,h);')
          else:
               f.write('\tTwoDLib::CSRAdapter csr_adapter(group,vecmat,h);')

def generate_grid_csr(fn, nodes, algorithms, connections, cuda):
    nodemap=node_name_to_node_id(nodes)
    gagmap=node_name_to_gag_id(nodes,algorithms)

    if len(gagmap) == 0:
        return

    with open(fn,'a') as f:
         f.write('\tconst std::vector<TwoDLib::CSRMatrix> vecmat {\\\n')

         if cuda == True:
              template_argument = 'fptype'
              group = ', group_ode,'
         else:
              group = ', group,'
              template_argument = 'MPILib::Rate'

         for el in list(gagmap.keys())[:-1]:
              f.write('\t\tTwoDLib::CSRMatrix(transform' + str(gagmap[el]) + group + str(gagmap[el]) + '), \\\n')
         el = list(gagmap.keys())[-1]
         f.write('\t\tTwoDLib::CSRMatrix(transform' + str(gagmap[el]) + group + str(gagmap[el]) + ') \\\n')
         f.write('\t};\n')

         map = construct_efficacy_map(nodes,algorithms,connections)

         f.write('\tstd::vector<' + template_argument + '> vec_gagin_rates(' + str(len(map)) + ',0.);\n')
         f.write('\tstd::vector<' + template_argument + '> vec_gagin_stays(' + str(len(map)) + ',0.);\n')

         if cuda:
              f.write('\tCudaTwoDLib::CSRAdapter csr_adapter(group,vecmat,h);\n\n')
         else:
              f.write('\tTwoDLib::CSRAdapter csr_adapter(group,vecmat,h);\n\n')


def create_cpp_file(xmlfile, dirpath, progname, modname, cuda):
    '''Write the C++ file specified by xmlfile into dirpath as progname.'''
    root=parse(xmlfile)
    variables, nodes, algorithms, connections, parameter, io=process_tree(root)
    if sanity_check(algorithms) == False: raise NameError('An algorithm incompatible with MeshAlgorithmGroup was used')
    if cuda == True:
         fn=os.path.join(dirpath, progname)+'.cu'
    else:
         fn=os.path.join(dirpath, progname)+'.cpp'

    generate_preamble(fn, variables, nodes, algorithms,connections,cuda)

    generate_mesh_algorithm_group(fn,nodes,algorithms,cuda)
    generate_grid_algorithm_group(fn,nodes,algorithms,cuda)

    generate_closing(fn)

def sanity_check(algorithms):
    '''Check if only the allowd algorithms feature in this simulation. Returns True if so, False otherwise.'''

    for algorithm in algorithms:
        if algorithm.attrib['type'] not in MESH_ALGORITHM_GROUP_LIST:
            return False
        else:
            return True

def mesh_algorithm_group(root):
    '''True if there are MeshAlgorithmGroup algorithms in the XML file, false otherwise.'''
    algorithms=root.findall('.//Algorithm')

    for algorithm in algorithms:
        if algorithm.attrib['type'] in ["MeshAlgorithmGroup","GridAlgorithmGroup"]:
            return True

    return False

def produce_mesh_algorithm_version(dirname, filename, modname, root, cuda):
    '''Entry point for the vector version of a MIIND C++ file. Filename is file name of the XML file, dirname is the user-specified directory hierarchy
    where the C++ file will be generated and the simulation will be stored. The simulation file will be placed in directory <dirname>/<xml_file_name>.'''

    if not directories.PATH_VARS_DEFINED:
        directories.initialize_global_variables()

    for xmlfile in filename:
        progname = directories.check_and_strip_name(xmlfile)
        dirpath = directories.create_dir(os.path.join(dirname, progname))
        directories.insert_cmake_template(progname,dirpath,cuda)
        create_cpp_file(xmlfile, dirpath, progname, modname, cuda)
        directories.move_model_files(xmlfile,dirpath)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Generate C++ from XML descriptions.')
    parser.add_argument('--d', help = 'Provide a packaging directory.',nargs = '?')
    parser.add_argument('-c', '--cuda', action="store_true", dest="cuda", help="if specified, cuda will be generated")
    parser.add_argument('-m','--m', help = 'A list of model and matrix files that will be copied to every executable directory.''', nargs='+')
    parser.add_argument('xml file', metavar='XML File', nargs = '*', help = 'Will create an entry in the build tree for each XML file, provided the XML file is valid.')
    parser.add_argument('--mpi', help = 'Enable MPI.', action='store_true')
    parser.add_argument('--openmp', help = 'Enable OPENMP.', action='store_true')
    parser.add_argument('--no_root', help = 'Disable ROOT.', action='store_true')

    args = parser.parse_args()


    filename = vars(args)['xml file']
    dirname  = vars(args)['d']
    modname  = vars(args)['m']
    enable_mpi = vars(args)['mpi']
    enable_openmp = vars(args)['openmp']
    disable_root = vars(args)['no_root']

    fn = filename[0]
    root=parse(fn)
    if mesh_algorithm_group(root) == True:
        # Run the MeshAlgorithm version
        produce_mesh_algorithm_version(dirname, filename, modname, root, vars(args)['cuda'])
    else:
        # Simply run the old script
        if dirname == None:
            fn = filename[0]
            directories.add_executable(fn,modname, enable_mpi, enable_openmp, disable_root)
        else:
            directories.add_executable(dirname, filename, modname, enable_mpi, enable_openmp, disable_root)
