// Copyright (c) 2005 - 2011 Marc de Kamps
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
//      and/or other materials provided with the distribution.
//    * Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software 
//      without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY 
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF 
// USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//      If you use this software in work leading to a scientific publication, you should cite
//      the 'currently valid reference', which can be found at http://miind.sourceforge.net
#ifndef _CODE_LIBS_MIINDLIB_XMLSIMULATION_INCLUDE_GUARD
#define _CODE_LIBS_MIINDLIB_XMLSIMULATION_INCLUDE_GUARD

#include <string>
#include "../DynamicLib/DynamicLib.h"
#include "../PopulistLib/PopulistLib.h"
#include "../UtilLib/UtilLib.h"
#include "XMLConnection.h"
#include "XMLNodes.h"
#include "XMLRunParameter.h"

using DynamicLib::SimulationRunParameter;
using UtilLib::Streamable;
using std::string;
/*! \page xml_structure The general structure of an XML simulation
 *  This page consists of the following sections:
 * <ol>
 * <li> \ref xml_structure_introduction</li>
 * <li> \ref xml_structure_io</li>
 * <li> \ref xml_algorithm_selection</li>
 * <li> \ref xml_constructing_nodes</li>
 * <li> \ref xml_adding_connections
 * </ol>
 *  \section xml_structure_introduction Introduction
 *  It is recommended that an XML file generated by the MIIND application (see \ref running_as_xml) is viewed in an XML editor. This can
 *  be even be a browser, like firefox. We use XML Copy Editor. In such an editor tags can be expanded or collapsed. Collapsing all tags
 *  leaves just the highest level
 * \verbatim
 +<Simulation></Simulation>
 * \endverbatim
 * Opening the first level reveals the structure of a simulation:
 * \verbatim
 -<Simulation>
	+<WeightType>Pop</WeightType>
	+<SimulationIO></SimulationIO>
	+<SimulationRunParameter></SimulationRunParameter>
	+<Algorithms></Algorithms>
	+<Nodes></Nodes>
	+<Connections></Connections>
 -</Simulation>
 * \endverbatim
 * All simulations are built this way. The only possible difference between simulations at this level is the type of the connections weights.
 * Two settings are possible: 'Pop' or 'double'. Many networks require a single number to charaterise the strength of connections in the network,
 * for example an efficacy. In that case use double. Other networks characterise the  strength of connections with more than one number.
 * PopulationConnections for example specify with what efficacy populations are connected, but also how many effective connections there are.
 * Networks have to use a single type of connection, and the algorithms used in the network simulation must be able to interpret them.
 * So the type of the connections must be determined at the start of the simulation. See \ref steady_state, for an example of PopulationConnection;
 * also see the general description of \ref DynamicLib, and the descriptions of OrnsteinUhlenbeckAlgorithm and PopulationAlgorithm for
 * more background on the use of the Pop WeightType.
 * 
 * Broadly speaking, the SimulationIO tag determines how the simulation results need to be stored and whether the results should be displayed
 * while the simulation is running. The SimulationRunParameter determines how long the simulation should run for, and how many intermediate
 * results should be stored. Algorithms contains all the algorithms used in the simulation. Each node is configured with an algorithm, and
 * after all the nodes have been defined, connections between the nodes are introduced. We will discuss each of these elements of the simulation
 * in turn.
 *
 * \section xml_structure_io Input and Output of the simulation <SimulationIO>
 * Opening the <SimulationIO> tag gives:
 * \verbatim
 		<SimulationIO>
			<SimulationName>two_pop</SimulationName>
			<OnScreen>TRUE</OnScreen>
			<WithState>TRUE</WithState>
			<WriteNet>FALSE</WriteNet>
			<CanvasParameter>
				<T_min>0</T_min>
				<T_max>0.3</T_max>
				<State_min>0</State_min>
				<State_max>1.0</State_max>
				<F_max>25</F_max>
				<Dense_max>4</Dense_max>
			</CanvasParameter>
			<CanvasNodes>Name="LIF E"</CanvasNodes>
		</SimulationIO>
   \endverbatim
  * The <SimulationName> tag specifies the name of the simulation: it will be used for storing the simulation results and as name
  * for the log file. The <OnScreen> tag determines whether the simulation results are displayed as the simulation is running. If
  * <WithState> is false, only the firing rate of a population is stored in the simulation results, otherwise, also the state of the algorithm
  * associated with the population. If <OnScreen> is true, also the nodes to be shown must be specified in the <CanvasNode> tag, otherwise
  * no results will be shown. The nodes that are visualized while the simulation is running are specified by their name (see \ref coniguring_nodes).
  *
  * The CanvasParameter tag will be explained in section \ref xml_example_single_population. 
  * \section xml_algorithm_selection Selecting Algorithms
  * Algorithms must match the weight type. WilsonCowanAlgorithm knows what to with contributions from other nodes if the connections between nodes are
  * given by a single number (a double). OrnsteinUhlenbeckalgorithm and PopulationAlgorithm know what to do with contributions from other nodes
  * if connections between nodes are of type PopulationConnection. In order to perform a simulation, of course you have to have some idea what
  * an algorithm does. WilsonCowanalgorithm is descibed in detail in \ref wilson_cowan. Here it is sufficient that it models the firing rate of a node.
  * It evolves the dynamics of a node using the following dynamics.
  * \f[
  * \tau \frac{dE_i}{dt} = -E_i + f( \sum w_{ij}E_j + I)
  * \f]
  * Here \f$\tau\f$ is the time constant of the population in s. \f$E_i\f$ is the firing rate of population in spikes/s. \f$I\f$ is external input
  * to the population in spikes/s and \f$w_{ij}\f$ are the weights of efficacies between populations. A number of examples of networks with
  * WilsonCowan dynamics are discussed in section \ref wilson_cowan.
  * RateAlgorithm is an algorithm that forces the associated node 
  * to contribute a constant presetrate to the network. Now consider the expanded <Algorithms> tag: 
  * \verbatim
	-<Algorithms>
		<AbstractAlgorithm type="WilsonCowanAlgorithm">
			<WilsonCowanAlgorithm Name="Wilson-Cowan excitatory Algorithm">
				<WilsonCowanParameter>
					<T_membrane>0.01</T_membrane><Rate_max>500</Rate_max>
					<Noise>1</Noise>
					<Input>0</Input>
				</WilsonCowanParameter>
			</WilsonCowanAlgorithm>
		</AbstractAlgorithm>
		<AbstractAlgorithm type="WilsonCowanAlgorithm"><WilsonCowanAlgorithm Name="Wilson-Cowan inhibitory Algorithm">
			<WilsonCowanParameter>
			<T_membrane>0.005</T_membrane>
				<Rate_max>500</Rate_max>
				<Noise>1</Noise>
				<Input>0</Input>
			</WilsonCowanParameter>
		</WilsonCowanAlgorithm></AbstractAlgorithm>
		<AbstractAlgorithm type="RateAlgorithm">
			<RateAlgorithm Name="Background Algorithm">
				1
			</RateAlgorithm>
		</AbstractAlgorithm>
	</Algorithms>
	\endverbatim
 *  It should be clear what is going on here. WilsonCowanAlgorithm needs to be configure with a WilsonCowanParameter (the only parameter not
 *	immediately obvious is the noise parameter, which is explaiend in \ref wilson_cowan and \ref_wilson_cowan_parameter, but usually can be
 *	left at the value used here). The algorithms are later referred to by their name, which is an ASCII string, where white space is allowed.
 *
 *  The algorithm stage is the only stage where simulations are truly different; setting the nodes and connections is more or less standard
 *  for all simulations. This is to be expected: to simulate, you must understand to some extent what it is you're simulating. But the structure
 *   of the XML file reflects the design philosophy of MIIND: constructing the networks and simulating the node processes are two very
 * different operations. Constructing networks can be done independently of modelling the node processes.
 *
 * \section xml_constructing_nodes Constructing nodes
 *  Constructing nodes is straightforward, consider the <Nodes> tag:
 * \verbatim
	-<Nodes>
		<Node name="E" type="EXCITATORY" algorithm="Wilson-Cowan excitatory Algorithm"></Node>
		<Node name="I" type="INHIBITORY" algorithm="Wilson-Cowan inhibitory Algorithm"></Node>
		<Node name="Background" type="INHIBITORY" algorithm="Background Algorithm"></Node>
	</Nodes>
	\endverbatim
 * Nodes have a name, a type (excitatory and inhibitory), and are associated with an algorithm. The algorithm tag must match the name of a 
 * previously defined algorithm exactly (surprised by an inhibitory background? - see the discussion of the sigmoid function in \ref wilson-cowan).
 *
 * \section xml_adding_connections Adding Connections
 * Adding of connections is equally straightforward:
 \verbatim
   -<Connections>
		<Connection In="E" Out="E">1</Connection>
		<Connection In="I" Out="I">2</Connection>
		<Connection In="E" Out="I">2</Connection>
		<Connection In="I" Out="E">-1.1</Connection>
		<Connection In="Background" Out="E">-1.5</Connection>
		<Connection In="Background" Out="I">-1.5</Connection>
	</Connections>
	\endverbatim
	*
	* \section xml_example_wilson_cowan A complete example of a simulation of Wilson-Cowan dynamics
	* For completeness the entire XML file is shown below. The simulation it defines is discussed in \ref wilson_cowan_complete.
	* The results of the simulation are shown here:
	* \image html dynamiclib_test_wilsoncowandouble.png
    * You can easily play around with some of the connections or node parameters and see if the
	* results match your expectations. You can also compare the XM file below with C++ code of \ref wilson_cowan_complete and you will find that
	* the code matches the XML structure very closely.
	* \verbatim
	<Simulation>
	<WeightType>double</WeightType>
	<SimulationIO>
		<SimulationName>wilson_cowan</SimulationName>
		<OnScreen>TRUE</OnScreen>
		<WithState>FALSE</WithState>
		<WriteNet>FALSE</WriteNet>
		<CanvasParameter>
			<T_min>0</T_min>
			<T_max>1</T_max>
			<State_min>0</State_min>
			<State_max>1</State_max>
			<F_max>20</F_max>
			<Dense_max>20</Dense_max>
		</CanvasParameter>
		<CanvasNodes></CanvasNodes>
	</SimulationIO>
	<SimulationRunParameter>
		<max_iter>10000000</max_iter>
		<t_begin>0</t_begin>
		<t_end>0.1</t_end>
		<t_report>1e-4</t_report>
		<t_state_report>1e-4</t_state_report>
		<t_step>1e-5</t_step>
		<t_update>0.001</t_update>
		<name_log>test/WilsonCowanAlgorithmTest.log</name_log>
	</SimulationRunParameter>
	<Algorithms>
		<AbstractAlgorithm type="WilsonCowanAlgorithm">
			<WilsonCowanAlgorithm Name="Wilson-Cowan excitatory Algorithm">
				<WilsonCowanParameter>
					<T_membrane>0.01</T_membrane>
					<Rate_max>500</Rate_max>
					<Noise>1</Noise>
					<Input>0</Input>
				</WilsonCowanParameter>
			</WilsonCowanAlgorithm>
		</AbstractAlgorithm>
		<AbstractAlgorithm type="WilsonCowanAlgorithm">
			<WilsonCowanAlgorithm Name="Wilson-Cowan inhibitory Algorithm">
				<WilsonCowanParameter>
					<T_membrane>0.005</T_membrane>
					<Rate_max>500</Rate_max>
					<Noise>1</Noise>
					<Input>0</Input>
				</WilsonCowanParameter>
			</WilsonCowanAlgorithm>
		</AbstractAlgorithm>
		<AbstractAlgorithm type="RateAlgorithm">
			<RateAlgorithm Name="Background Algorithm">
			1
			</RateAlgorithm>
		</AbstractAlgorithm>
	</Algorithms>
	<Nodes>
		<Node name="E" type="EXCITATORY" algorithm="Wilson-Cowan excitatory Algorithm"></Node>
		<Node name="I" type="INHIBITORY" algorithm="Wilson-Cowan inhibitory Algorithm"></Node>
		<Node name="Background" type="INHIBITORY" algorithm="Background Algorithm"></Node>
	</Nodes>
	<Connections>
		<Connection In="E" Out="E">1</Connection>
		<Connection In="I" Out="I">-2</Connection>
		<Connection In="E" Out="I">2</Connection>
		<Connection In="I" Out="E">-1.1</Connection>
		<Connection In="Background" Out="E">-1.5</Connection>
		<Connection In="Background" Out="I">-1.5</Connection>
	</Connections>
	</Simulation>
	\endverbatim
	* \section xml_example_single_population An example of the simulation of a single leaky-integrate-and fire population using population density techniques
	* In \ref population_algorithm the details of a population density algorithm for leaky-integrate-and-fire neurons are explained. For the
	* discussion of this example, it is sufficient to know that an entire population can be represented by a density function. When \f$V\f$ denotes
	* the membrane potential of an individual leaky-integrate-and-fire (LIF) neuron, an entire population can be described by a density
	* function \f$\rho(V)\f$, which indicates how the membrane distributions in the population are distributed. More precisely:
	* \f$\rho(V) dV \f$ is the fraction of the neuronal population that have membrane potential in the interval \f$[V, V+ dV) \f$.
	* So the population is characterised by an entire function, rather than by a single number, like the average firing rate of
	* a Wilson-Cowan (\ref wilson_cowan) population. To characterise the algorithm, first one needs to define the variables that determine
	* a LIF neuron. These are determined by OrnsteinUhlenbeckParameter. It will be clear to anyone familiar with LIF neurons how the
	* OrnsteinUhlenbeck parameter defines a LIF neuron (and thereby of the population, which is assumed to be homogeneous).
	*
	*
	* An XML file for the study of a single leaky-integrate-and fire population looks like this:
	* \verbatim
	<Simulation>
		<WeightType>Pop</WeightType>
		<SimulationIO>
			<SimulationName>two_pop</SimulationName>
			<OnScreen>TRUE</OnScreen>
			<WithState>TRUE</WithState>
			<WriteNet>FALSE</WriteNet>
			<CanvasParameter>
				<T_min>0</T_min>
				<T_max>0.3</T_max>
				<State_min>0</State_min>
				<State_max>1.0</State_max>
				<F_max>25</F_max>
				<Dense_max>4</Dense_max>
			</CanvasParameter>
			<CanvasNodes>Name="LIF E"</CanvasNodes>
		</SimulationIO>
		<SimulationRunParameter>
			<max_iter>1000000</max_iter>
			<t_begin>0</t_begin>
			<t_end>0.3</t_end>
			<t_report>1e-003</t_report>
			<t_state_report>0.03</t_state_report>
			<t_step>1e-004</t_step>
			<t_update>1e-003</t_update>
			<name_log>test/twopoptest.log</name_log>
		</SimulationRunParameter>
		<Algorithms>
			<AbstractAlgorithm type="PopulationAlgorithm">
				<PopulationAlgorithm Name="LIF_excitatory Algorithm">
					<OrnsteinUhlenbeckParameter>
						<t_membrane>0.050</t_membrane>
						<t_refractive>0.002</t_refractive>
						<V_threshold>1.0</V_threshold>
						<V_reset>0</V_reset>
						<V_reversal>0</V_reversal>
					</OrnsteinUhlenbeckParameter>
					<PopulationSpecific>
						<N_grid>500</N_grid>
						<N_add>1</N_add>
						<InitialDensity> 0 0 </InitialDensity>
						<expansion>1.1</expansion>
						<zeroleak>NumericalZeroLeakEquations</zeroleak>
						<Circulant>CirculantSolver</Circulant>
						<NonCirculant>NonCirculantSolver</NonCirculant>
					</PopulationSpecific>
				</PopulationAlgorithm>
			</AbstractAlgorithm>
			<AbstractAlgorithm type="RateAlgorithm">
				<RateAlgorithm Name="Cortical Background Algorithm">
					800
				</RateAlgorithm>
			</AbstractAlgorithm>
		</Algorithms>
		<Nodes>
			<Node name="LIF E" type="EXCITATORY" algorithm="LIF_excitatory Algorithm"></Node>
			<Node name="Cortical Background" type="EXCITATORY_BURST" algorithm="Cortical Background Algorithm"></Node>
		</Nodes>
		<Connections>
			<Connection In="Cortical Background" Out="LIF E">1 0.03</Connection>
		</Connections>
	</Simulation>
	\endverbatim
	* \section xml_example_double_population An example of a simple neural circuit:a coupled excitatory-inhibitory circuit driven by an extrenam input - balanced excitation-inhibition
	\verbatim
	<Simulation>
		<WeightType>Pop</WeightType>
		<SimulationIO>
			<SimulationName>two_pop</SimulationName>
			<OnScreen>TRUE</OnScreen>
			<WithState>TRUE</WithState>
			<WriteNet>FALSE</WriteNet>
			<CanvasParameter>
				<T_min>0</T_min>
				<T_max>0.05</T_max>
				<State_min>0</State_min>
				<State_max>0.02</State_max>
				<F_max>10</F_max>
				<Dense_max>250</Dense_max>
			</CanvasParameter>
			<CanvasNodes>Name="LIF E" Name="LIF I"</CanvasNodes>
		</SimulationIO>
		<SimulationRunParameter>
			<max_iter>1000000</max_iter>
			<t_begin>0</t_begin>
			<t_end>0.05</t_end>
			<t_report>1e-005</t_report>
			<t_state_report>0.05</t_state_report>
			<t_step>1e-005</t_step>
			<t_update>1e-005</t_update>
			<name_log>test/twopoptest.log</name_log>
		</SimulationRunParameter>
		<Algorithms>
			<AbstractAlgorithm type="PopulationAlgorithm">
				<PopulationAlgorithm Name="LIF_excitatory Algorithm">
					<OrnsteinUhlenbeckParameter>
						<t_membrane>0.01</t_membrane>
						<t_refractive>0.002</t_refractive>
						<V_threshold>0.02</V_threshold>
						<V_reset>0</V_reset>
						<V_reversal>0</V_reversal>
					</OrnsteinUhlenbeckParameter>
					<PopulationSpecific>
						<N_grid>1100</N_grid>
						<N_add>1</N_add>
						<InitialDensity> 0 0 </InitialDensity>
						<expansion>1.1</expansion>
						<zeroleak>NumericalZeroLeakEquations</zeroleak>
						<Circulant>CirculantSolver</Circulant>
						<NonCirculant>NonCirculantSolver</NonCirculant>
					</PopulationSpecific>
				</PopulationAlgorithm>
			</AbstractAlgorithm>
			<AbstractAlgorithm type="PopulationAlgorithm">
				<PopulationAlgorithm Name="LIF_inhibitory Algorithm">
					<OrnsteinUhlenbeckParameter>
						<t_membrane>0.003</t_membrane>
						<t_refractive>0.002</t_refractive>
						<V_threshold>0.02</V_threshold>
						<V_reset>0</V_reset>
						<V_reversal>0</V_reversal>
					</OrnsteinUhlenbeckParameter>
					<PopulationSpecific>
						<N_grid>1100</N_grid>
						<N_add>1</N_add>
						<InitialDensity> 0 0 </InitialDensity>
						<expansion>1.1</expansion>
						<zeroleak>NumericalZeroLeakEquations</zeroleak>
						<Circulant>CirculantSolver</Circulant>
						<NonCirculant>NonCirculantSolver</NonCirculant>
					</PopulationSpecific>
				</PopulationAlgorithm>
			</AbstractAlgorithm>
		<AbstractAlgorithm type="RateAlgorithm">
			<RateAlgorithm Name="Cortical Background Algorithm">
				2
			</RateAlgorithm>
		</AbstractAlgorithm>
	</Algorithms>
	<Nodes>
		<Node name="LIF E" type="EXCITATORY" algorithm="LIF_excitatory Algorithm"></Node>
		<Node name="LIF I" type="INHIBITORY" algorithm="LIF_inhibitory Algorithm"></Node>
		<Node name="Cortical Background" type="EXCITATORY" algorithm="Cortical Background Algorithm"></Node>
	</Nodes>
	<Connections>
		<Connection In="LIF E" Out="LIF E">10000 0.000117647</Connection>
		<Connection In="LIF I" Out="LIF I">2000 -0.00085531</Connection>
		<Connection In="LIF E" Out="LIF I">10000 0.000285103</Connection>
		<Connection In="LIF I" Out="LIF E">2000 -0.000352941</Connection>
		<Connection In="Cortical Background" Out="LIF E">10000 0.000117647</Connection>
		<Connection In="Cortical Background" Out="LIF I">10000 0.000285103</Connection>
	</Connections>
</Simulation>
\endverbatim
 */

namespace MiindLib {

	//! This class collects all XML counterparts of a real simulation and compiles the XML counterpart of a complete simulation.
	//! This can then be written to a stream, where it can be used by a SimulationBuilder to instantiate a real simulation.
	template <class Weight>
	class XMLSimulation : public Streamable {
	public:

		typedef boost::shared_ptr<DynamicLib::AbstractAlgorithm<Weight> > algorithm_pointer;
		typedef vector<algorithm_pointer>		algorithm_vector;
		typedef vector<XMLConnection<Weight> >	connection_vector;

		XMLSimulation();

		XMLSimulation
		(
			const string&,
			const XMLRunParameter&,
			const SimulationRunParameter&,
			const algorithm_vector&,
			const node_vector&,
			const connection_vector&
		);

		virtual ~XMLSimulation();

		virtual bool ToStream(ostream&) const;

		virtual bool FromStream(istream&);

		virtual string Tag() const;

	private:

		string					_connection_type_name;
		XMLRunParameter			_par_run_xml;
		SimulationRunParameter	_par_run;
		algorithm_vector		_vec_alg;
		node_vector				_vec_nodes;
		connection_vector		_vec_con;

	};

}

#endif // inlcude guard